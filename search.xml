<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一个简单maven项目的打包与运行]]></title>
    <url>%2F2019%2F03%2F24%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[一个简单maven项目的打包与运行标题描述的不是很准确,应该说,一个包含外部依赖包的maven包的项目的打包以及运行. 创建maven工程目录结构如下 添加依赖包此处以fastjson为例,在pom.xml里添加依赖如下 123456789&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.15&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写demo1234567public class TestPackMain &#123; public static void main(String[] args) &#123; Map map = new HashMap(); map.put(&quot;a&quot;, &quot;b&quot;); System.out.println(JSON.toJSONString(map)); &#125;&#125; 打包 在pom.xml里添加如下打包配置 此处主要配置两点 jar包默认运行的main函数 编译时的java版本 1234567891011121314151617181920212223242526272829&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;pack.TestPackMain&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 执行打包命令 1package assembly:single 运行jar包 1java -jar maven-package-demo-1.0-SNAPSHOT-jar-with-dependencies.jar 控制台输出 1&#123;&quot;a&quot;:&quot;b&quot;&#125; 如果依赖的是内部的包,怎么办?//todo]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot中的拦截器与过滤器]]></title>
    <url>%2F2019%2F03%2F20%2Fspringboot%E4%B8%AD%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[springboot中的拦截器与过滤器关于过滤器和拦截器的区别,在此不展开,仅仅记录下在一个springboot项目中如何配置生效过滤器以及拦截器 过滤器一般来讲,我们会使用FilterRegistrationBean来注册过滤器.使用流程如下: 定义过滤器123456789101112131415161718public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;doFilter&quot;); filterChain.doFilter(servletRequest, servletResponse); return; &#125; @Override public void destroy() &#123; &#125;&#125; 在这个过滤器中,我们仅仅是打印日志,之后将调用链接着传递 配置过滤器1234567891011@Configurationpublic class FilterConfig &#123; @Bean public FilterRegistrationBean CASFilter()&#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.addUrlPatterns(&quot;/*&quot;); Filter filter = new MyFilter(); registration.setFilter(filter); return registration; &#125;&#125; 注意Configuration和Bean注解的使用 注意过滤器的作用范围(registration.addUrlPatterns) 编写测试接口1234567@RestControllerpublic class TestController &#123; @RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET) public String test() &#123; return &quot;test&quot;; &#125;&#125; 调用测试接口可以看到控制台打印如下: 1doFilter 后记 过滤器经常被用在登录请求的校验中,也可以用在一些请求的加解密当中. 多个过滤器可以通过设置优先级达到确定执行顺序的目的. 拦截器自定义拦截器123456789101112131415161718public class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion&quot;); &#125;&#125; 注意重载的preHandle的返回值,如果返回false,则请求不会接着往下走. 配置拦截器1234567@Configurationpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MyInterceptor()); &#125;&#125; 调用测试接口可以看到控制台打印如下 1234doFilterpreHandlepostHandleafterCompletion 很直观的可以看到执行顺序. 后记关于拦截器和过滤器的区别,只能再仔细研究,再开一篇.]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot前后端分离实践]]></title>
    <url>%2F2019%2F03%2F19%2Fspringboot%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[springboot前后端分离实践前言现在很多项目都是采用springboot+react或者springboot+angularJs的模式进行开发,相对应的部署方式我认为主要有两种 打包后将前端静态文件放在resource下的文件夹里面 利用nginx的反向代理,将前端文件与后台程序分开部署. 而这两者中,我认为后者相对来说更好一些. 部署要点:nginx反向代理 安装nginx1yum install nginx 常用命令如下 1234nginx nginx -s stopnginx -s reloadnginx -t 默认配置文件位置 1/etc/nginx/nginx.conf 配置nginx重要:配置文件位置/etc/nginx/nginx.conf 配置前端文件目录在对应的server里配置 1root /usr/share/nginx/html 备注:默认为此,不需要设置 配置反向代理在对应的server里配置 123location /api/ &#123; proxy_pass http://localhost:8083/api/; &#125; 备注:此处的localhost:8083为springboot项目启动的机器ip和端口,也就是说前后端不需要部署在同一台机器上. 部署springboot1将springboot程序包部署启动 后记 很多人可能会有疑问,为什么要用反向代理呢?其实原因很简单:跨域.如果仅仅是将nginx作为前端的容器,然后由前端去直接请求springboot后台接口的话,是会有跨域问题的,这些请求是会被浏览器拦截的. 运用nginx的负载均衡,更进一步的话,我们可以在反向代理的时候通过nginx的upstream功能来实现负载均衡,可以指定轮询的策略.]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot数据库与mybatis]]></title>
    <url>%2F2019%2F03%2F18%2Fspringboot%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8Emybatis%2F</url>
    <content type="text"><![CDATA[springboot数据库与mybatis入门配置初始化工程参考链接:https://blog.csdn.net/typa01_kk/article/details/76696618 数据库配置以及测试在application.properties配置如下 12345678spring.datasource.url=jdbc:mysql://127.0.0.1:3306/testspring.datasource.username=rootspring.datasource.password=passwordspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.max-idle=10spring.datasource.max-wait=10000spring.datasource.min-idle=5spring.datasource.initial-size=5 通过jdbcTemplate的方式访问数据库 12345678910111213141516171819@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoSpringbootApplicationTests &#123; @Autowired JdbcTemplate jdbcTemplate; @Test public void contextLoads() &#123; String sql = &quot;select * from user&quot;; List&lt;Map&lt;String, Object&gt;&gt; resultList = jdbcTemplate.queryForList(sql); System.out.println(&quot;query result:&quot; + JSON.toJSONString(resultList)); for (Map&lt;String, Object&gt; item: resultList) &#123; for (Map.Entry&lt;String, Object&gt; entry: item.entrySet()) &#123; System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue().toString()); System.out.println(&quot;\n&quot;); &#125; &#125; &#125;&#125; 日志打印如下: 12345query result:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;&#125;]id:1name:test 成功访问数据库. mybatis配置一般来讲,我们都是通过mybatis以及xml的方式访问数据库. 添加dao接口 12345678/** * @author wuweizhao * @version 创建时间：2019/3/18 9:26 PM */@Mapperpublic interface UserMapper &#123; List&lt;Map&gt; querUser();&#125; 添加mapper.xml文件(文件位置:resources/mapper/UserMapper.xml) 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.demospringboot.dao.UserMapper&quot;&gt; &lt;select id=&quot;querUser&quot; resultType=&quot;java.util.Map&quot;&gt; SELECT id, name FROM user &lt;/select&gt;&lt;/mapper&gt; 添加配置信息(application.properties) 1mybatis.mapper-locations=classpath:mapper/**/*.xml 编写测试代码 123456@Autowired UserMapper userMapper; @Test public void testMybatis() &#123; System.out.println(JSON.toJSONString(userMapper.querUser())); &#125; 查看控制台打印信息 1[&#123;&quot;name&quot;:&quot;test&quot;,&quot;id&quot;:1&#125;] 完整的application.properties配置文件如下 12345678910111213spring.datasource.url=jdbc:mysql://127.0.0.1:3306/testspring.datasource.username=rootspring.datasource.password=passwordspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.max-idle=10spring.datasource.max-wait=10000spring.datasource.min-idle=5spring.datasource.initial-size=5server.port=8083server.tomcat.uri-encoding=UTF-8mybatis.mapper-locations=classpath:mapper/**/*.xml 完整的pom.xml文件如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo-springboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo-springboot&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 参考 https://blog.csdn.net/typa01_kk/article/details/76696618 https://blog.csdn.net/zhoujiyu123/article/details/79786847]]></content>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于java 中的equals的一些记录]]></title>
    <url>%2F2018%2F10%2F21%2F%E5%85%B3%E4%BA%8Ejava-%E4%B8%AD%E7%9A%84equals%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[override equals方法的几个原则 自反性。对于任何非null的引用值x，x.equals(x)应返回true。 对称性。对于任何非null的引用值x与y，当且仅当：y.equals(x)返回true时，x.equals(y)才返回true。 传递性。对于任何非null的引用值x、y与z，如果y.equals(x)返回true，y.equals(z)返回true，那么x.equals(z)也应返回true。 一致性。对于任何非null的引用值x与y，假设对象上equals比较中的信息没有被修改，则多次调用x.equals(y)始终返回true或者始终返回false。 示例代码(String类的equals方法): 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; list中的indexOf,contains方法根据equals方法来判断对象是否相等 override hashCode方法从Object类中的源码可以看到重载equals之后需要重载hashCode的提示 123If two objects are equal according to the &#123;@code equals(Object)&#125;* method, then calling the &#123;@code hashCode&#125; method on each of* the two objects must produce the same integer result. String 类的hashCode代码: 123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; Map接口会使用,可以简单理解为通过hashCode方法算出该变量的地址,那么当两个变量相等,那么这个算出来的hashCode也势必需要相等. 编写equals的建议下面给出编写一个完美的equals方法的建议（出自Java核心技术 第一卷：基础知识）： 显式参数命名为otherObject,稍后需要将它转换成另一个叫做other的变量（参数名命名，强制转换请参考建议5） 检测this与otherObject是否引用同一个对象 ：if(this == otherObject) return true;（存储地址相同，肯定是同个对象，直接返回true） 检测otherObject是否为null ，如果为null,返回false.if(otherObject == null) return false; 比较this与otherObject是否属于同一个类 （视需求而选择） 如果equals的语义在每个子类中有所改变，就使用getClass检测 ：if(getClass()!=otherObject.getClass()) return false; (参考前面分析的第6点) 如果所有的子类都拥有统一的语义，就使用instanceof检测 ：if(!(otherObject instanceof ClassName)) return false; 将otherObject转换为相应的类类型变量：ClassName other = (ClassName) otherObject; 现在开始对所有需要比较的域进行比较 。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true，否则就返回flase。 如果在子类中重新定义equals，就要在其中包含调用super.equals(other) 当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明 相等对象必须具有相等的哈希码 。 参考equals解读]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https-nginx配置]]></title>
    <url>%2F2018%2F10%2F17%2Fhttps-nginx%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[转载https://bitmingw.com/2017/02/02/letsencrypt-tutorial/]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>https</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试https图床]]></title>
    <url>%2F2018%2F06%2F23%2F%E6%B5%8B%E8%AF%95https%E5%9B%BE%E5%BA%8Aimgur%2F</url>
    <content type="text"><![CDATA[https图床 在给网站添加了https之后,发现访问的时候依然处于不安全的状态,查看提示之后才知道是七牛图床的协议导致的 在页面上存在http的链接的时候,浏览器仍然会提示不安全. 为了访问页面时的小绿锁,势必得寻找一个https的图床了. 七牛云是有提供https支持的,只是需要在七牛云添加备案后的域名,由于网站并不打算备案,所以这条路就行不通了 国内的其他一些有提供https图床的服务又有点不靠谱,说不定哪天就跑路了呢 微博的图床服务似乎也不是很稳定 imgur,这个又有被墙的风险 腾讯云对象存储,这个似乎比较靠谱一些,只是没有一些比较趁手的工具 估计还是得用imgur吧,或者用腾讯云,再或者就是尽量采用代码以及描述性的文字来写博客吧(┓( ´∀` )┏) imgur图片测试 腾讯云对象存储]]></content>
  </entry>
  <entry>
    <title><![CDATA[session与cookie]]></title>
    <url>%2F2018%2F02%2F07%2Fsession%E4%B8%8Ecookie%2F</url>
    <content type="text"><![CDATA[session与cookiecookie 在服务端中设置,在前端中需要看情况 当设置了httponly时,仅能在服务端设置,js端既不能读取也不能够设置. 无设置httponly时,前端也可以设置和读取cookie的值 session 需要注意的是,session指的是”对话” req.getSession().setAttribute(&quot;session&quot;, &quot;value&quot;); 按照如上的代码, req.getSession().getAttribute(&quot;session&quot;) 就可以获得value值 可以想象成服务器维持了一个map,map的key是sessionID,而值则是一个个的键值对,而sessionID的传递方式则是通过cookie来实现的(在初始化session时会生成并且设置cookie,而之后cookie的提交则会带上sessionID) 除此之外,在禁用cookie的情况下,还能通过url重写的方式来实现sessionID的传递 在分布式部署的情况下,session的同步是一个问题,比较简单的解决方式是使用spring session+redis实现.]]></content>
      <tags>
        <tag>java</tag>
        <tag>java web</tag>
        <tag>session</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-scrapy]]></title>
    <url>%2F2018%2F01%2F28%2Fpython-scrapy%2F</url>
    <content type="text"><![CDATA[scrapy爬虫框架入门 安装 开始项目以及创建爬虫(参照命令行工具) scrapy startproject myproject //初始化项目 cd myproject scrapy genspider mydomain mydomain.com //创建spider 项目的文件目录以及功能 item.py: 数据格式的定义 (爬虫名称).py: 具体的爬虫逻辑 pipelines.py: 对爬虫得到的数据(item进行处理) settings.py: 对爬虫的一些定义(比如指定pipelines等) 除此之外,比较实用的命令还有 以给定的URL(如果给出)或者空(没有给出URL)启动Scrapy shell,运行之后你可以在命令行中使用response选择器,这样就可以进行网页页面的分析而不用每次都启动spider scrapy shell &quot;url&quot; ....略过执行代码 response.xpath(&quot;//h1[@class=&apos;post-title&apos;]/a&quot;) //选择器 运行指定的spider scrapy crawl &lt;spider&gt; -o 输出的文件 * 更多的命令可以查看[http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/commands.html](http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/commands.html) 自定义爬虫item(items.py) import scrapy class TutorialItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() title = scrapy.Field() link = scrapy.Field() # pass 定义爬虫逻辑(爬虫名称.py) class WuweizhaoSpider(scrapy.Spider): name = &apos;wuweizhao&apos; allowed_domains = [&apos;wuweizhao.com&apos;] start_urls = [&apos;http://wuweizhao.com/&apos;] def parse(self, response): list = response.xpath(&quot;//h1[@class=&apos;post-title&apos;]/a&quot;) url = &quot;http://wuweizhao.com/&quot; for a in list: yield scrapy.Request(url + a.xpath(&quot;./@href&quot;)[0].extract(), callback=self.parse_contents) next_page = response.xpath(&quot;//nav/a[@class=&apos;extend next&apos;]/@href&quot;).extract_first() if next_page is not None: next_page = url + next_page print(next_page) next_page = response.urljoin(next_page) yield scrapy.Request(next_page, callback=self.parse) def parse_contents(self, response): item = TutorialItem() item[&quot;title&quot;] = response.xpath(&quot;//h1[@class=&apos;post-title&apos;]/text()&quot;).extract_first().replace(&quot;\n&quot;, &quot;&quot;).strip() item[&quot;link&quot;] = response.request.url yield item start_urls爬虫启动时访问的url yield关键字: 新的Request:会将url加入到访问队列当中 item(继承scrapy.Item的类):输出到命令行或者相应的文件当中(根据启动参数而定) 自定义item处理(如果有需要的话) 修改settings.py中的选项ITEM_PIPELINES 修改pipelines.py class TutorialPipeline(object): def __init__(self): pass def process_item(self, item, spider): return item 参考http://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/overview.htmlhttp://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/selectors.html]]></content>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-tips]]></title>
    <url>%2F2018%2F01%2F28%2Fpython-tips%2F</url>
    <content type="text"><![CDATA[python-tips列表生成式 Python内置的非常简单却强大的可以用来创建list的生成式 写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来 生成器 当我们需要创建100万个元素的列表的时候,如果这些元素可以按照一定的规则去生成,那么我们就不需要在内存中同时维护这100万个元素,而是通过在迭代中边去生成元素来实现. 把一个列表生成式的[]改成()，就创建了一个generator 需要注意的是,我们一般不会显式调用next方法,而是使用for in迭代 如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。 generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。]]></content>
      <tags>
        <tag>python</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servletRequest中读取body的问题]]></title>
    <url>%2F2018%2F01%2F26%2FservletRequest%E4%B8%AD%E8%AF%BB%E5%8F%96body%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ServletRequest中读取body的数据InputStream body = request.getInputStream(); 问题 数据流仅仅能够读取一次,如果你想要多次读取(在多个调用链中)(比如说在多个过滤器中),例如 chain.doFilter(request, response); 这样后面的调用中request将读取不到body的数据. 解决 继承实现HttpServletRequest接口的HttpServletRequestWrapper,重载getInputStream方法. 具体实现BufferedServletRequestWrapper类public class BufferedServletRequestWrapper extends HttpServletRequestWrapper { private byte[] buffer; public BufferedServletRequestWrapper(HttpServletRequest request) throws IOException { super(request); InputStream is = request.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte buff[] = new byte[ 1024 ]; int read; while( ( read = is.read( buff ) ) &gt; 0 ) { baos.write( buff, 0, read ); } this.buffer = baos.toByteArray(); } @Override public ServletInputStream getInputStream() throws IOException { return new BufferedServletInputStream( this.buffer ); } } 在过滤器中ServletRequest requestWrapper = new BufferedServletRequestWrapper(req); InputStream inputStream = requestWrapper.getInputStream(); String content = IOUtils.toString(inputStream, req .getCharacterEncoding()); /**对内容进行处理**/ chain.doFilter(requestWrapper, response); /**由于我们在初始化时保存了byte,重载了getInputStream方法,所以后续调用时可以获得body中的数据**/]]></content>
      <tags>
        <tag>java web</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF浅析]]></title>
    <url>%2F2018%2F01%2F24%2FCSRF%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[CSRF浅析什么是CSRFCross-site request forgery,跨站请求伪造. 简单的攻击样例 小明访问并且登录了网站A 小明访问坏人的网站B,网站B上存在一些网站A的请求(GET或者POST) 一个简单的get请求可以利用img的src属性: &lt;img src=&quot;http://example.com/get?xxx=xxx&quot;&gt; 访问时触发了请求,此时由于请求中携带着相关的cookie信息,所以网站A是会通过这些非法的请求的,也就是跨站(在黑客网站B)请求伪造. 预防referer验证这是一种不安全的校验方法 校验原理对于网络请求,在header里面存在着referer属性,这个属性标识出请求的来源网站,所以我们可以通过验证referer来预防csrf攻击 存在问题 对于某些浏览器来说,这个属性可能为空 referer可以轻易地伪造 从搜索引擎跳转时,referer是搜索引擎,所以可能需要维护一个白名单 双提交cookie较为安全 实现对于每一个网络请求,在提交请求时,在js中将cookie中的某些值(可以是单独生成的token或者用户标志灯)添加到header上提交,在后台去校验是否存在token以及是否与cookie的值相匹配 原理当你在访问坏人的网站B时,同时提交的仅仅只有cookie,而你在正常访问时,提交时会在header中添加csrftoken. 问题其实也不能算是问题吧,如果你的网络请求是统一到一个方法里面执行的,例如说ajax或者dwr,那么就可以很方便地修改,但是如果不是的话,那么修改的工作量可能就有点大了. 参考https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html]]></content>
      <tags>
        <tag>web安全</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web线程安全]]></title>
    <url>%2F2018%2F01%2F24%2Fweb%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[java web中的线程安全问题问题描述:伪代码:判断redis是否有相应的键值对: 有: 读取redis 没有: 读取数据库 插入redis(列表的插入) 返回 问题当请求并发时,第一个请求redis未插入而第二个请求也进入了判断,此时第二个请求的判断条件也是”否”,所以就会出现redis数据重复的情况. 原因虽然说对于每一个单独的请求,spring都是新建一个单独的线程来进行处理,但是这并不能够解决上面的问题,究其原因,则是访问了同一个全局数据(可以认为是redis) 解决:增加一个全局变量,使用synchronize同步方法,伪代码如下 伪代码全局变量 lock 判断redis是否有相应的键值对: 有: 读取redis 没有: synchronize(lock) 再次判断redis是否有相应的键值对 有: 读取redis 没有: 读取数据库 插入redis 再次判断的原因:加锁只是阻塞了第二个请求的读取数据库/插入redis操作,如果没有再次判断的话,那么当第一个请求释放锁之后第二个请求依旧会再次读取数据库/插入redis,问题依旧存在 参考http://www.cnblogs.com/doit8791/p/4093808.html]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域请求]]></title>
    <url>%2F2017%2F11%2F14%2F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[跨域资源请求CORS1.什么是跨域资源请求 通常情况下,我们访问一个网站的过程如下: 访问页面example.com,加载页面html以及js 对页面进行一些操作,由js通过ajax访问后台,进行页面的更新. 一般情况下,通过ajax调用后台是同源的,同源指的是: 协议相同 端口号相同 地址相同 但是有时候通过js请求非同源的后台服务,这个时候就是属于跨域资源请求了 2.问题 由于Ajax的同源设置策略,所以如果我们直接请求非同源的地址的话,会出现错误 3.解决方法1. 作为用户 安装chrome插件Allow-Control-Allow-Origin后启用即可.2.作为开发者 当浏览器发现ajax请求是跨域请求时,会在请求头上面添加origin字段,这个字段将作为服务器指定是否允许同源请求的地址 在服务器上,我们需要配置web.xml中SpringServlet的初始化参数,如下 其中,CrosbyFilter代码如下: public class CrosFilter implements ContainerResponseFilter { @Override public ContainerResponse filter(ContainerRequest creq, ContainerResponse cres) { cres.getHttpHeaders().add("Access-Control-Allow-Origin", "*"); cres.getHttpHeaders().add("Access-Control-Allow-Headers", "Content-Type, msgversion"); cres.getHttpHeaders().add("Access-Control-Allow-Credentials", "true"); return cres; } } 需要注意的是头部添加的三个值: Access-Control-Allow-Origin:其值为允许跨域访问的源地址,可以为*匹配所有或者具体的源地址 Access-Control-Allow-Headers:CORS请求时,XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定,如上面代码所示,在返回里面添加了msgversion的头部信息,如果不需要额外信息此项可不写 Access-Control-Allow-Credentials:表示是否允许发送Cookie,这个值也只能设为true，如果服务器不要浏览器发送Cookie，不要添加该字段即可 修改之后,跨域访问时可以看到返回的内容为:3.总结 总的来说,简单跨域请求主要的操作是还是在服务器端进行操作,大部分浏览器都能够自动地进行跨域的访问,上面所提到的也仅仅是简单的跨域资源请求,更多的资料可以去查看http://www.ruanyifeng.com/blog/2016/04/cors.html jQuery中ajax请求的跨域问题最近用到了百度地图的web api,想要通过ajax get来获得内容,没想到都跨域了.解决方法如下(其中success的值为自定义的回调函数) var options = { type: &quot;get&quot;, dataType:&quot;jsonp&quot;, jsonp:&quot;callback&quot;, url: serviceURL, //dataType: &apos;json&apos;, timeout: timeout || 20000,//超时时间设置，单位毫秒 success: callBack }; $.ajax(options); 原理JSONP参考http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html中JSONP部分内容 局限jsonp只能是解决get方法的跨域问题,如果是post的话,还是需要修改服务器的相关内容(参照上面解决方法中开发者的部分)]]></content>
      <tags>
        <tag>http</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入剖析tomcat笔记]]></title>
    <url>%2F2017%2F10%2F30%2F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90tomcat%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[servlet reponse request 启动连接器-&gt;等待连接-&gt;调用container容器-&gt;解析header,调用servlet]]></content>
  </entry>
  <entry>
    <title><![CDATA[Maven实战读书笔记]]></title>
    <url>%2F2017%2F10%2F11%2FMaven%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Maven实战常用命令 mvn clean compile mvn clean test mvn clean package 默认打包为jar,可以在pom.xml里面指定打包类型 mvn clean install 将项目打包后安装到本地仓库以供其他项目使用 默认打包生成的jar时不能够直接运行的,为了生成可执行的jar文件,需要借助maven-shade-plugin]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术卷读书笔记]]></title>
    <url>%2F2017%2F10%2F11%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Java核心技术卷(一)读书笔记数据类型整型 int 4字节 long 8字节 short 2字节 byte 1字节 需要注意的是字节长度与平台无关,与c语言不同 浮点型 float 4字节,一般不够用 double 8字节 遵循IEEE754标准 char类型 16位,字符常量,用单引号括起来 16位,65536个不同的值 一个char代表一个代码单元,但是并不一定代表一个代码点. 一个代码点可以认为是一个字符,例如’a’,’中’,但是其中可能前者只包含一个代码单元,而后者包含两个代码单元 boolean 类型字符串 String类型 与C,C++不同的是,字符串并非是字符数组,也不提供修改字符串的方法,其目的在于编译器可以让字符串共享,因为各种字符串存在一个公共的存储池当中. 使用equals方法来判定是否相等 length方法:返回的是字符长度,也就是代码单元数量 getBytes().length() 可以返回字节长度,需要指定编码方式. 通过StringBuilder来构建字符串 面向对象 依赖 use a 聚合 has a 继承 is a 一个对象变量并不拥有一个对象,而仅仅是引用一个对象 final变量:构建对象时必须初始化final变量,但是并不意味着此变量不能被改变,而仅仅意味着变量的引用不能够改变,但是如果引用的对象是不可变对象时(例如String),则可以认为此变量是不能够被改变的 static变量:静态变量,类级别共享的变量 方法参数,注意到java总是按照值传递的方式调用函数(call by value) 静态初始化块,在类第一次加载的时候将会进行静态域的初始化继承 final类和方法可以阻止继承,以免子类改变语义 只能在继承层次进行类型转换,同时在进行(继承链)向下的转换时,先用instanceof进行类型判断方法调用 动态绑定 查看对象的声明类型和方法名称 查看调用方法时提供的参数类型 非静态绑定时采用动态绑定的方式调用方法,调用的方法依赖于隐式参数(this)的实际类型. 调用与对象的实际类型最适合的类方法. 为了减少每次搜索的开销,编译器维护一个方法表,其中列出了所有方法的签名和实际调用的方法 静态绑定 private方法 static方法 final方法 equals方法的几个特性 自反性 a.equals(a) 为true 对称性 传递性 一致性:反复调用应该返回一样的结果 x.equals(null) 返回false hashcode方法 一个hash方法,由对象导出的一个整型,每个对象都有一个默认的hashcode,其值为对象的存储地址 equals和hashCode的定义必须一致:调用的返回结果必须相同 反射 Class类:表示一个特定类的属性,具体而言,Class是一个类,而某个具体类的class(例如int.Class)则是对象,其类是Class. newInstance()方法初始化对象 getFields():返回public 域数组 getMethods() getConstructors() todo 动态绑定 todo instanceof equals hashCode 枚举类 反射 克隆 内部类]]></content>
      <tags>
        <tag>java</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的面向对象程序设计]]></title>
    <url>%2F2017%2F08%2F28%2FJavaScript%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[JavaScript中的面向对象程序设计1.最简单的模式1.1 新建实例添加属性和方法var person = new Object(); person.name = &quot;name&quot;; person.sayHi = function() { console.log(&quot;hi&quot;); } console.log(person.name); person.sayHi(); 1.2 对象字面量 与上面的方法其实是相同的,仅仅是书写上简化了一些而已. var person = { name : &quot;name&quot;, sayHi : function() { console.log(&quot;hi&quot;); } } 如果你要构造多个对象的话,那么以上的模式的问题就显而易见了:产生大量的重复代码,而函数就是解决重复代码的利器. 2.工厂模式function createPerson() { var o = { name : &quot;name&quot;, sayHi : function() { console.log(&quot;hi&quot;); } } return o; } 3. 构造函数模式function Person(name) { this.name = name; this.sayHi = function() { console.log(&quot;hi&quot;); } } person = new Person(&quot;name&quot;); 使用构造函数模式新建对象时,经历了以下的四个步骤: 创建一个新对象 将构造函数的作用域赋给新对象(this关键字指向创建的新对象) 执行构造函数中的代码 返回新对象 关于this 的具体含义,可以参考阮一峰的网络日志-Javascript的this用法 现在我们解决了构造多个对象时的重复代码问题,但是其实还有另外一个问题:每一个方法都需要在每个实例上重新创建一遍,而原型模式可以解决这个问题. 4. 原型模式4.1 原型 每个函数都有prototype(原型)属性,这个属性指向一个原型对象,而这个对象为所有实例共享(包括对象里面的属性以及方法). 值得注意的是,在实例中的变量会屏蔽掉原型模式中的同名变量.4.2 使用 function Person(name) {this.name = name; this.sayHi = function() { console.log(&quot;hi&quot;); } } Person.prototype.sayName = function() {console.log(this.name) }; 或者我们也可以通过对象字面量的方式来实现: Person.prototype = { constructor: Person, a: &quot;a&quot; } 4.3 问题随着共享随之而来的问题是:对共享变量的修改可能会影响到你的预期输出结果,所以使用时还请慎重. 5. 混合使用原型模式和构造函数模式function Person(name) { this.name = name; this.sayHi = function() { console.log(&quot;hi&quot;); } } Person.prototype = { constructor: Person, a: &quot;a&quot; } 继承function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; } function SubType() { this.subproperty = false; } SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() { return this.subproperty; } var instance = new SubType(); alert(instance.getSuperValue());]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis入门以及整合spring]]></title>
    <url>%2F2017%2F08%2F23%2Fmybatis%E5%85%A5%E9%97%A8%E4%BB%A5%E5%8F%8A%E6%95%B4%E5%90%88spring%2F</url>
    <content type="text"><![CDATA[mybatis入门什么是mybatis MyBatis是一个Java持久化框架，它通过XML描述符或注解把对象与存储过程或SQL语句关联起来(from维基百科)准备工作 mybatis的jar包 一个数据库(我采用的是mysql)具体如下数据库结构如下 my-batis文件 配置文件,配置连接的数据库,账户名,密码等,同时指定使用到的mapper的位置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/db_develop&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper url=&quot;file:///F:/IDEAProject/WebAppLearn/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; mapper文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.wilbert.mapper.UserMapping&quot;&gt; &lt;select id=&quot;getUser&quot; resultType=&quot;com.wilbert.model.User&quot;&gt; select * from tb_user where id = #{id} &lt;/select&gt; &lt;/mapper&gt; 注意其中的namespace,命名空间,可以将其认为是java中的包,而id则为java中具体的类,这样在下面的调用就比较好理解了. 数据模型类,一个普通的java类,拥有getter,setter方法. 测试类 public class MyBatisLearn { public static void main(String[] args) throws IOException { String resource = &quot;src/main/java/com/wilbert/config/mybatis-config.xml&quot;; InputStream inputStream = new FileInputStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); String statement = &quot;com.wilbert.mapper.UserMapping.getUser&quot;; User user = sqlSession.selectOne(statement, &quot;5b6f8d5739834dddb785c5e909471e69&quot;); } } 需要注意的是statement,statement是由namespace+id构成. 运行结果 id:5b6f8d5739834dddb785c5e909471e69,name:a,password:a 后续 从上面可以看到,其中至关重要的是mapper文件,在mapper文件中我们配置了各式各样的sql,而mybatis也提供了很强大的语法来实现复杂的查询或者插入,更新等.详情可以进一步查看http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html 参考资料:http://www.mybatis.org/mybatis-3/zh/getting-started.html]]></content>
      <tags>
        <tag>mybatis</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA NIO]]></title>
    <url>%2F2017%2F08%2F23%2FJAVA-NIO%2F</url>
    <content type="text"><![CDATA[参考资料:https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html 主要概念: 通道(channel) 缓冲区(buffer) 主要思想: 在原来的IO的思想上封装,提高IO效率 方法: 通过缓冲区实现基于块的读写 具体: 先获得文件的输入输出流–&gt;从文件的输入输出流获得通道(channel)–&gt;分配缓冲区(buffer)–&gt;从缓冲区中读取内容/将内容写入缓冲 缓冲区内部细节:缓冲区的底层实现可以看成是一个字节数组, 三个变量 position:当前索引,也可以理解为指针所指的元素,初始值为0,指向第一个元素 limit:初始值为capacity,通过与position以clear函数和flip函数结合来确定写入写出的元素. capacity:总容量,可以理解为数组长度,limit&lt;=capacity flip函数1.将limit设置为position的值2.将position设置为0将buffer写入到输出通道时,调用此函数,注意在写入到输出通道时(foutchanel.write(buffer)),position会步进,而limit不变,所以想要循环读取时,需要调用clear函数重置缓冲区的状态. clear函数1.将limit设置为capacity的值2.将position设置为0 文件输入输出流会记住输入输出的位置,每个字节仅能被读取一次.]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高级程序设计之面向对象]]></title>
    <url>%2F2017%2F08%2F01%2FJava%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Java高级程序设计之面向对象对象使用对象字面量来创建对象 对于对象的每一个属性来说,,都有两种类型的属性来确实其性质: 数据属性 Configureable 是否可配置,该属性指定对象是否可以配置(主要指的是数据属性) Enumerable 是否可遍历,指定for in时是否返回 Writable Value 属性的数据值,例如person中的属性name的值wilbert 访问器属性 Configureable 是否可配置,该属性指定对象是否可以配置(主要指的是数据属性) Enumerable 是否可遍历,指定for in时是否返回 Writable Value 属性的数据值,例如person中的属性name的值wilbert Get Set var person = { name: &quot;wilbert&quot;, sayHello: function () { console.log(&quot;hello!world!&quot;) } } Object.defineProperty(person, &quot;name&quot;, { get: function () { return name + &quot;test&quot;; }, set: function (newValue) { name = newValue; } }) person.name = &quot;abcd&quot;; console.log(person.name); //输出 abcdtest 注意,仅能通过Object.defineProperty()或者Object.defineProperties()方法来对上述属性进行修改. 工厂模式 使用一个普通的函数,在函数中新建Object并且设定其属性,之后返回这个对象构造函数模式 function Person(name, password) {this.name = name; this.password = password; this.sayHello = function () { console.log(&quot;Hello!&quot;); } } person = new Person(‘a’, ‘a’); 使用new操作符来创建对象可以使用instanceof来判断对象类型 构造函数也可以看成普通的函数来调用,注意此时的this的作用域(一般情况下是windows) 缺点:每个方法都相当于重新实例化了一遍,这个问题可以通过原型模式property解决原型模式 每个构造函数都存在着prototype属性,这个属性指向一个原型对象,默认原型对象仅有constructor属性,constructor属性中又存在着指向构造函数的指针,如图 而通过构造函数实例化的对象都存在一个无法访问的指针[[prototype]]指向同一个原型对象. 指针的获得方式 Object.getPrototypeof(person) 所以我们可以通过构造函数的prototype属性来设置原型对象从而达到公用函数或者变量的目的. 注意,访问一个对象的属性时的访问顺序:先访问自身的值,如果不存在,再访问原型对象中的值. 动态原型模式看代码 function Person(name, password) { this.name = name; this.password = password; if(typeof this.sayHello != &quot;function&quot;) { Person.prototype.sayHello = function () { console.log(this.name + this.password); } } } 结合了构造函数与原型模式的优点,使其在使用上与普通的C/C++系的类更加相同. 继承顺着上面的原型链继续写点关于继承的内容. 实现方法:设置子类(SubType)的原型属性(prototype)为父类(SuperType)的实例. 大概原理 图片 代码大致如下 function Man(age) { this.age = age; this.name = &quot;test sub&quot;; } Man.prototype = new Person(&quot;sub&quot;, &quot;sub&quot;); man = new Man(&quot;10&quot;); man.sayHello(); //访问Person类的方法 console.log(man.name); //访问Person类的属性 此时情况如下: man中的[prototype]指向Person(父类)的实例对象person person类中的[prototype]指向Person(父类)的原型对象 Person(父类)的原型对象的Constructor中存在指向Person的指针 综上,构成了一条原型链,而根据属性的访问规则: 访问一个对象的属性时的访问顺序:先访问自身的值,如果不存在,再顺着原型链直至查找到对象为止. 重点在于 构造函数存在prototype指向原型对象; 默认原型对象的构造函数存在指向构造函数的指针; 对象实例(通过构造函数创建)存在指向原型对象的指针. 可以通过 instanceOf判断类型 给原型添加方法的代码一定要放在替换原型的语句之后.]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL记录(二)]]></title>
    <url>%2F2017%2F07%2F31%2FSQL%E8%AE%B0%E5%BD%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[聚集函数MIN()MAX()AVG()SUM() COUNT() 函数 count(*) 将对表中行的数目进行计数 count(column) 会略过值为null的列tips*可以使用distinct关键字仅指定不同值的行. select count(distinct column)….. 分组数据关键字: Group by 根据指定的列来进行分组 select cID, count(*) as numberfrom ProductsGroup by cID; 根据cID进行分组,返回cID以及相对应的数目 除了聚集计算语句之外,select的每个字段必须为分组的依据(出现在group by之后) group by 出现在where子句之后,order by之前. Having 筛选分组 HAVING和WHERE的区别在于一个是在分组之前过滤(where,不符合条件的记录不参与分组),一个是在分组之后进行过滤(HAVING).联结 join 等值联结,又称内联结 inner join on where … =]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript高级程序设计笔记]]></title>
    <url>%2F2017%2F07%2F18%2Fjavascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[使用var定义的变量为局部变量 省略var定义的变量为全局变量 五种简单数据类型 Undefined 声明变量但是未初始化时变量的值 Null 表示一个空对象的指针,在变量还没有真正保存对象时,应该明确让其保存null值. Boolean 任何非空字符串为真 任何非零数字值为真,0和NaN为假 Number isNaN() 函数确实一个值是否”不是数值”,注意其判断的过程会检测其toString的值,例如isNaN(‘1’)返回false(意思是’1’是一个数字) parseInt函数 String 复杂数据类型 Object 变量,作用域和内存问题 在if以及for语句中定义的变量在循环执行结束后依旧存在. Array数组的使用//todo 创建数组的几种不同方式 var colors = new Array() var colors = new Array(3) var colors = new Array(‘A’, ‘B’) var colors = [] 注意,数组的length属性的动态性,可以通过直接设置其值来达到动态调整数组长度的目的 Array.isArray(colors)方法判断是否是数组 concat方法拼接返回新的数组 slice方法 一个参数时返回开始位置直至结束的数组 两个参数时返回指定位置之间的数组(包含开始但不包含结束位置的项 splice方法 参数一:删除的第一项的位置 参数二:删除的项数 参数三,四,…n:插入的值 indexOf方法,从头开始查找,不存在返回-1 lastIndexOf,从结尾开始查找,不存在返回-1 迭代方法 every() filter() forEach() map() some() 注意,迭代方法的参数均为一个函数,此函数的参数为(item,index,array) 缩小方法(进行数组的迭代求和等) reduce(function(prev, cur, index, array) {}) reduceRight(function(prev, cur, index, array) {}) Date类型的使用 //todo]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL记录(一)]]></title>
    <url>%2F2017%2F07%2F17%2FSQL%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[distinct关键字 通过distinct让数据库只返回不同的数值,注意,当查询多列数字时,只有当所有列内容相同才会视其为相同的数值. 使用时,将distinct关键字置于列名之前. order by 排序 应该保证order by子句是select语句中的最后一条子句,否则将会报错. 可以使用非选择的列进行排序 可以选择按照多个列进行排序,排序优先级按照出现顺序,也就是说先按照a条件排序,当a条件相同时在按照b条件进行进一步的排序. desc 逆序排列,注意此关键字只作用在其指定的列上(与之不同的是distinct关键字,它作用于选择的所有列上),也就是说,如果按照两列的逆序排列的话,你需要分别在这两列列名后使用desc where 筛选 范围值检查,使用between and操作符 空值检查 IS NULL子句(注意,不能够使用 =NULL) 空值指的是NULL,而非存在值但是值为0 AND OR关键字 注意两者的求值顺序,总是使用括号来显示指定求值顺序 IN (… , …) 实现与OR操作符类似的功能 NOT 进行否定,一般多用于 NOT IN() LIKE操作符 通配符搜索只能用于文本字段 % 通配符 表示任何字符出现任何次数(包含0次) _ 仅匹配单个字符 [] 指定字符集,与正则表达式类似,只是它总是刚好匹配指定字符集之中的一个字符.例如[JM],使用[^JM]表示除了JM之外的任一字符. 计算字段 拼接字段 连接 || 连接 TRIM()/LTRIM()/RTRIM()函数:去除空格 算术计算 AS 别名 将计算字段或者某一个已有的字段(即列)重命名为其他值并且返回]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo第三方服务添加]]></title>
    <url>%2F2017%2F07%2F16%2Fhexo%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1%E6%B7%BB%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[通常来讲为next主题添加第三方服务(例如添加评论系统,使用百度统计,腾讯分析等)的过程都是类似的: 注册网站,获得相应的appID或者key 在主题的配置文件中设置相应的appID或者key 重新生成并部署hexo即可 leancloud为next主题添加统计信息搜索功能添加 采用了next主题提供的local search功能 来必力评论系统添加参考next主题第三方服务添加]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下编译安装nginx]]></title>
    <url>%2F2017%2F04%2F13%2Fubuntu%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85nginx%2F</url>
    <content type="text"><![CDATA[Ubuntu下编译安装nginx 参考这里 安装完成之后，编辑修改nginx.conf， 路径是 /usr/local/nginx/conf/nginx.conf 启动nginx sudo /usr/local/nginx/sbin/nginx 关闭nginx sudo /usr/local/nginx/sbin/nginx -s stop 重读nginx配置文件 sudo /usr/local/nginx/sbin/nginx -s reload]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>nginx</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vps+git+hexo+nginx搭建博客网站]]></title>
    <url>%2F2017%2F04%2F13%2Fvps-git-hexo-nginx%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[vps+git+hexo+nginx搭建博客网站由于科学上网的需要，买了一个vps，想着单单用来ss似乎不太值，所以就想说搭建一个简单的博客系统，wordpress比较繁杂，所以就采用了这样的一个方式来搭建博客：git+hexo（主题：next）+nginx，实现思路大概是这样子的： 在本地windows上搭建hexo，编写博客之后hexo generate，生成html文件 在vps上搭建git服务器，nginx服务 将本地html文件更新到服务器上 使用git hook功能将服务器git目录更新到网页文件上 windows上搭建hexo官方文档安装完成。 vps安装git服务安装gitsudo apt-get install git 创建git用户sudo adduser git 初始化git仓库，存放目录 /var/repo/sudo mkdir /var/repo cd /var/repo sudo git init --bare blog.git 创建git hooks创建自定义钩子,指定特定的重要动作发生时触发自定义脚本,创建的是服务端钩子 post-receive，具体内容可以查看这里 cd /var/repo/blog.git/hooks vim post-receive 在post-receive加入如下内容 #!/bin/sh git --work-tree=/var/www/hexo --git-dir=/var/repo/blog.git checkout -f 注意，其中/var/www/hexo目录是您的nginx的网站目录，请根据需要进行修改 修改文件的可执行权限 chmod +x post-receive 改变 blog.git 目录的拥有者为 git 用户：sudo chown -R git:git blog.git vps安装nginx服务见这里 windows本地配置修改hexo目录下的_config.yml文件中的deploy deploy: type: git repo: git@weizhaowu.me:/var/repo/blog.git branch: master 具体的使用hexo new &quot;new-post&quot; hexo clean &amp;&amp; hexo generate --deploy 这样博客就会自动更新到网站上面了。 参考使用 Git Hook 自动部署 Hexo 到个人 VPS]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>nginx</tag>
        <tag>vps</tag>
        <tag>git</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[by以及having的使用]]></title>
    <url>%2F2016%2F10%2F28%2Fsql%E4%B8%ADgroup%20by%E4%BB%A5%E5%8F%8Ahaving%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[group by 与 having 分组:将表格中的数据按照某一列进行分组,通常会搭配聚合函数使用,常见的聚合函数有如下几种 sum avg count min max eg 存在一个表格,结构如下 http://www.sqlcourse2.com/items_ordered.html 将订单按照customerid进行分组,并且算出每一个客户对应的订单总价 select i.customerid, sum(price) from items_ordered i group by i.customerid having sum(price) &gt; 100; tips: 假设存在另外一个表:存放customerid以及相应的客户信息.当你想要联合查询时,一般是先join之后再进行group by的操作 having是在分组之后上面进行的操作,而where的操作是在原来的每一条记录上面进行操作. select i.customerid, avg(price) from items_ordered i where i.price &gt; 10 and i.price &lt; 100 group by i.customerid having sum(price) &gt; 100; 这个查询语句的意思是:在表中先找出price在10和100之间的项,将其按照customerid进行分组,在每个分组中找出总价值大于100的分组,打印出其customerid以及平均价值.]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的synchronized和volatile]]></title>
    <url>%2F2016%2F10%2F26%2FJava%E4%B8%AD%E7%9A%84synchronized%E5%92%8Cvolatile_todo%2F</url>
    <content type="text"><![CDATA[volatile关键字 程序在运行时,为了提高性能可能会将主存中的变量拷贝到CPU缓存当中, 如果是非volatile变量,那么就可能会出现这样的问题: 线程1读取变量并且进行修改,在还没有将其写会主存的时候,线程2读取同一个变量此时就出现了问题.因为非volatile变量无法保证什么时候从主存中读取数据,也无法保证什么时候写回主存. 图示 volatile变量则可以确保了变量的修改会及时写回主存、变量直接从主存中读取 synchronized关键字 引用 http://tutorials.jenkov.com/java-concurrency/volatile.html]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的单例模式]]></title>
    <url>%2F2016%2F10%2F26%2FJava%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java中的单例模式 多线程中可能会导致对象的多次初始化.懒汉式的实现 之所以成为懒汉,个人认为应该是类的初始化只在需要的时候进行,所以很”懒”. 线程不安全 /*懒汉 非线程安全*/ public class SingleTon_01 { private static SingleTon_01 singleTon_01 = null; private SingleTon_01() { } public static SingleTon_01 getSingleTon_01() { if (singleTon_01 == null) { singleTon_01 = new SingleTon_01(); } return singleTon_01; } public void print() { System.out.println(&quot;singleton_01&quot;); } } 线程安全/*懒汉 线程安全*/ public class SingleTon_02 { private static SingleTon_02 singleTon_02 = null; private SingleTon_02() {} private static synchronized SingleTon_02 getSingleTon_02() { if (singleTon_02 == null) { singleTon_02 = new SingleTon_02(); } return singleTon_02; } } 饿汉实现 在类加载时就进行初始化,可能会产生垃圾对象,但是不会有多线程的问题出现. /*饿汉式*/ public class SingleTon_03 { private static SingleTon_03 singleTon_03 = new SingleTon_03(); private SingleTon_03() { } public static SingleTon_03 getSingleTon_03() { return singleTon_03; } } 双重校验锁模式 要注意变量需要添加volatile关键字. 假设有两个进程分别调用了getInstance方法,进程A首先将变量复制到CPU0缓存当中,进行初始化操作,如果没有volatile关键字,那么进程B在调用此方法时复制到CPU1缓存中的可能是未被更新的null,此时问题就出现了. /*双重校验锁模式*/ public class SingleTon_04 { private static volatile SingleTon_04 singleTon_04 = null; private SingleTon_04() { } public static SingleTon_04 getSingleTon_04() { if (singleTon_04 == null) { synchronized (SingleTon_04.class) { singleTon_04 = new SingleTon_04(); } } return singleTon_04; } } 静态内部类实现 通过classloader机制确保初始化时只有一个线程 /*静态内部类*/ public class SingleTon_05 { private static class InstanceHolder{ private static SingleTon_05 singleTon_05 = new SingleTon_05(); } private SingleTon_05() { } public SingleTon_05 getSingleTon_05() { return InstanceHolder.singleTon_05; } } enum实现public enum SingleTon_06 { INSTANCE; public void print() { System.out.println(&quot;singleTon_06&quot;); } }]]></content>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android动画学习]]></title>
    <url>%2F2016%2F10%2F19%2Fandroid%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[根据google官方的动画学习 https://developer.android.com/training/animation/index.htmlCrossfading Two Views 两个view的切换：淡入淡出效果的实现 应用场景：进度条加载完成之后内容的显示 页面代码 实现效果：在activity打开之后progressBar的alpha值逐渐下降到0直至可见性为GONE，而文本的内容的alpha值逐渐上升到1。 动画代码 private void crossfade() { // Set the content view to 0% opacity but visible, so that it is visible // (but fully transparent) during the animation. mContentView.setAlpha(0f); mContentView.setVisibility(View.VISIBLE); // Animate the content view to 100% opacity, and clear any animation // listener set on the view. mContentView.animate() .alpha(1f) .setDuration(mShortAnimationDuration) .setListener(null); // Animate the loading view to 0% opacity. After the animation ends, // set its visibility to GONE as an optimization step (it won&apos;t // participate in layout passes, etc.) mLoadingView.animate() .alpha(0f) .setDuration(mShortAnimationDuration) .setListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { mLoadingView.setVisibility(View.GONE); } }); } some tips mShortAnimationDuration = getResources().getInteger( android.R.integer.config_shortAnimTime); //200ms view.animate() 返回值为ViewPropertyAnimator,可以对其进行view上的某一个property的动画操作（例如alpha） 可以设置动画开始/结束等的监听事件，ViewPager切换效果 重点在于Viewpager的函数 mPager.setPageTransformer(true, new DepthPageTransformer()); 其中函数的第二个参数为PageTransformer接口 public interface PageTransformer { /** * Apply a property transformation to the given page. * * @param page Apply the transformation to this page * @param position Position of page relative to the current front-and-center * position of the pager. 0 is front and center. 1 is one full * page position to the right, and -1 is one page position to the left. */ public void transformPage(View page, float position); } position: 0: 前台居中 1: 前台右侧 -1:前台左侧 ZoomOutPageTransformerpublic class ZoomOutPageTransformer implements ViewPager.PageTransformer { private static final float MIN_SCALE = 0.85f; private static final float MIN_ALPHA = 0.5f; @Override public void transformPage(View view, float position) { int pageWidth = view.getWidth(); int pageHeight = view.getHeight(); if (position &lt; -1) { // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); } else if (position &lt;= 1) { // [-1,1] // Modify the default slide transition to shrink the page as well float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); float vertMargin = pageHeight * (1 - scaleFactor) / 2; float horzMargin = pageWidth * (1 - scaleFactor) / 2; if (position &lt; 0) { view.setTranslationX(horzMargin - vertMargin / 2); } else { view.setTranslationX(-horzMargin + vertMargin / 2); } // Scale the page down (between MIN_SCALE and 1) view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); // Fade the page relative to its size. view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA)); } else { // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); } } } 根据position对view进行位置的偏移(translation)以及大小的缩放(scale)以及透明度(alpha)的调整. DepthPageTransformerpublic class DepthPageTransformer implements ViewPager.PageTransformer { private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) { int pageWidth = view.getWidth(); if (position &lt; -1) { // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); } else if (position &lt;= 0) { // [-1,0] // Use the default slide transition when moving to the left page view.setAlpha(1); view.setTranslationX(0); view.setScaleX(1); view.setScaleY(1); } else if (position &lt;= 1) { // (0,1] // Fade the page out. view.setAlpha(1 - position); // Counteract the default slide transition view.setTranslationX(pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); } else { // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); } } } Displaying Card Flip Animations 简单来讲,这个应该指的是一些页面切换时候的动画 getFragmentManager() .beginTransaction() // Replace the default fragment animations with animator resources // representing rotations when switching to the back of the card, as // well as animator resources representing rotations when flipping // back to the front (e.g. when the system Back button is pressed). .setCustomAnimations( R.animator.card_flip_right_in, R.animator.card_flip_right_out, R.animator.card_flip_left_in, R.animator.card_flip_left_out) // Replace any fragments currently in the container view with a // fragment representing the next page (indicated by the // just-incremented currentPage variable). .replace(R.id.container, new CardBackFragment()) // Add this transaction to the back stack, allowing users to press // Back to get to the front of the card. .addToBackStack(null) // Commit the transaction. .commit(); 核心方法为:setCustomeAnimations 具体的代码可以参见https://developer.android.com/training/animation/cardflip.htmlZooming a ViewAnimating Layout Changes layout布局变化的时候的动画是自带的,配置如下: &lt;LinearLayout android:id=&quot;@+id/container&quot; android:animateLayoutChanges=&quot;true&quot; ... /&gt; 接下来只需要直接在代码中addView中就可以了. 下一篇要写的是属性动画的另外一些应用]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java正则表达式SomeTips]]></title>
    <url>%2F2016%2F10%2F16%2FJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[默认的写法均为贪婪的 加?之后修改为最短匹配 Pattern pattern = Pattern.compile(&quot;\\d{1,3}&quot;); String s = &quot;123-456-789&quot;; Matcher matcher = pattern.matcher(s); Matcher类 matches() 方法返回boolean，判断整个字符串是否符合pattern。 find() 方法返回boolean， 判断字符串中是否存在子串符合pattern,通过group()方法获得匹配的子串。 while (matcher.find()) { System.out.println(matcher.group()); }]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android动画简介]]></title>
    <url>%2F2016%2F10%2F10%2Fandroid%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[ViewAnimation视图动画基类是Animation，包含的子类有 AlphaAnimation 透明度动画 TranslateAnimation 平移动画 ScaleAnimation 缩放动画 RotateAnimation 旋转动画 AnimationSet 动画集合 定义方法 java代码 xml文件定义 xml文件 res-&gt;anim-&gt;view_alpha.xml java文件 Animation animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.view_alpha); PropertyAnimation属性动画 google官方api 与视图动画的区别 视图动画比较局限,仅能够修改view对象,局限于view对象的一些特定属性:例如scale,alpha等. 视图动画仅仅是修改了view绘制的地方而非view本身的属性.(在你移动一个按钮到新的位置时,点击新的位置的按钮并不能够触发事件监听)ValueAnimator 使用: ValueAnimator animation = ValueAnimator.ofFloat(0f, 1f); animation.setDuration(1000); animation.start(); 一般不直接使用这个,因为其只能够修改值而不能够将其值作用于目标上,这个类一般是作为下面的ObjectAnimator的内部实现. 常用的几个方法为ofFloat ofInt ofArgb ofObject. ofObject时需要传递实现了TypeEvaluator接口的类以提供计算方法.TypeEvaluator文档ObjectAnimator 使用: ObjectAnimator anim = ObjectAnimator.ofFloat(foo, &quot;alpha&quot;, 0f, 1f); anim.setDuration(1000); anim.start(); 常用的方法与ValueAnimator相同 第一个参数是target,即需要进行操作的类 第二个参数是property,target类中存在的变量,需要有setter方法,当setter方法不存在时: 添加方法 使用包装类 使用valueAnimator类 注意,有时候可能需要在动画的update监听器当中调用view的invalidate()方法来进行页面的重画. tips 通过调用addListener添加动画监听器 由于AnimatorListener需要实现的方法较多,所以google提供了另外一个实现了AnimatorListener接口的抽象类AnimatorListenerAdapter,你只需要实现这个类里面的某个方法即可(当你仅仅需要监听其中的某个方法的时候),其他方法默认为空实现.xml定义动画 定义在res下的animator文件夹中 &lt;set android:ordering=&quot;sequentially&quot;&gt; &lt;set&gt; &lt;objectAnimator android:propertyName=&quot;x&quot; android:duration=&quot;500&quot; android:valueTo=&quot;400&quot; android:valueType=&quot;intType&quot;/&gt; &lt;objectAnimator android:propertyName=&quot;y&quot; android:duration=&quot;500&quot; android:valueTo=&quot;300&quot; android:valueType=&quot;intType&quot;/&gt; &lt;/set&gt; &lt;objectAnimator android:propertyName=&quot;alpha&quot; android:duration=&quot;500&quot; android:valueTo=&quot;1f&quot;/&gt; &lt;/set&gt; java代码 AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.anim.property_animator); set.setTarget(myObject); set.start(); 还未涉及到的… animatorset 动画集合的使用 xml定义动画的具体使用:当valueType时的处理方法]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见布局]]></title>
    <url>%2F2016%2F10%2F10%2Ftodo%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[LinearLayout 线性布局 分为水平（horizontal）布局以及垂直布局（vertical） 一般使用layout-weight来分隔页面，使用layout-weight时，推荐将height（垂直布局时）或者weight（水平布局时）设置为0. RelativeLayout&lt;!–more__&gt; 相对布局 可以相对其他控件，也可以相对父控件TableLayout 表格布局 每一行TableRowFrameLayout 帧布局AbsoluteLayout 绝对布局 基本不用]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TravelMap]]></title>
    <url>%2F2016%2F10%2F08%2FtravelMap%2F</url>
    <content type="text"><![CDATA[Activity通知更新Fragment：通过Fragment的onAttach()函数以及使用handler：在Fragment类中定义handler成员并且重载handleMessage()函数，在handlerMessage函数中进行根据Message的信息来进行相应的操作来更新Fragment，那么怎么将Activity怎么使用这个handler呢？因为他们并不是在同一个类中，所以我在Activity中也有一个handler，在OnAttach的时候将其赋值为handler，一开始有考虑将这个handler设置为fragment类的静态成员变量，但是考虑到这样会带来其他的问题（静态成员变量就与具体的对象无关而与类相关了）。 Fragment通知更新Activity数据由Activity来实现一个接口，在Fragment的onAttach函数中可以将这个接口传递给Fragment，再通过这个接口来调用我们想要更新的Activity的数据。 Bitmap oom其实这个问题我们一开始也没有想到。因为我负责的那一块在显示一些图片的时候一直会有问题，经常是整个黑色的什么都没有，但是队友做的那部分却一切正常。所以也是被这个问题坑了很久。知道问题后解决其实就不麻烦了，通过使用BitmapFactory的一些选项设置可以达到获得缩略图片的效果，自然问题也就迎刃而解了。 同一个界面，判断是否是不同的使用类型因为在同一个界面上，我们可能是想要新建一个项，也可能是想要编辑一个项，那怎么判断比较好呢？最后我们的解决方法是使用一个布尔值得成员变量来帮助判断，而在其他界面跳转过来时根据携带的信息来确定这个成员变量的布尔值。 拍照很坑的地方当时是使用一个startActivityForResult的方法来启动相机并且传入了相应的Uri，因为需要保存文件，同时也需要将拍到的照片在界面上面显示出来，所以，坑的地方就出现了，在返回的data里面获得的图片是空的，本来还想着说能够很方便地把结果给显示出来，没想到还是得根据uri自己去把图片加载出来。 ListView的优化架构每个Activity均实现同一个接口，实现接口函数。新建一个继承自Handler的类，重载handlerMessage函数，在函数中调用上述提到的接口函数，。然后我们再在Thread中调用使用handler就可以了。 使用ViewPager时滑动冲突新建一个类继承自ViewPager，直接将其滑动事件禁用掉。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android序列化]]></title>
    <url>%2F2016%2F10%2F08%2Fandroid%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[实现Serializable接口Serializable接口是来自Java的序列化接口 使用方法class BagOfPrimitives implements Serializable{ public int value1 = 1; public String value2 = &quot;abc&quot;; public transient int value3 = 3; } 在Intent中传递对象时 取出对象实现Parcelable接口Android自带的接口，性能更高，但通用性不强使用方法如下 Parcel为参数的构造函数中，给变量赋值 writeToParcel(Parcel dest, int flags)将变量的值写入dest public class Person implements Parcelable { private int data; private Book book; protected Person(Parcel in) { data = in.readInt(); book = in.readParcelable(Book.class.getClassLoader()); } public static final Creator&lt;Person&gt; CREATOR = new Creator&lt;Person&gt;() { @Override public Person createFromParcel(Parcel in) { return new Person(in); } @Override public Person[] newArray(int size) { return new Person[size]; } }; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeInt(data); dest.writeParcelable(book, flags); } } 重点 序列化的成员变量也需要实现Parcel接口，同时读取以及写入方式如下 读取 book = in.readParcelable(Book.class.getClassLoader()); 写入 dest.writeParcelable(book, flags); 传递对象时 接收对象时]]></content>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA中的引用]]></title>
    <url>%2F2016%2F10%2F07%2FJAVA%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[强引用 最普遍的情况 宁愿抛出OOM也不会将其回收 可以通过将引用设置为null来弱化引用，便于gc回收对象软引用 SoftReference 内存空间足够时不会回收，如果内存空间不足了，就会将其回收。 String str=new String(&quot;abc&quot;); // 强引用 SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str); 弱引用WeakReference 比软引用更加弱，当垃圾收集器回收时就会被回收。虚引用]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于RecyclerView以及ListView中的图像加载问题]]></title>
    <url>%2F2016%2F10%2F07%2F%E5%85%B3%E4%BA%8ERecyclerView%E4%BB%A5%E5%8F%8AListView%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ListView 中出现错位，重复的图片 原因：为了性能的提升，我们一般会采取重复使用item的方式，应用仅仅需要inflate n（屏幕所能显示的item总数）个view而非数据的size个view，这样可以极大地提高效率，如下 public View getView(int position, View convertView, ViewGroup parent) { ViewHolder holder = null; if (convertView != null) { holder = (ViewHolder)convertView.getTag(); } else { convertView = mInflater.inflate(R.layout.item_list_view, parent, false); holder = new ViewHolder(); holder.imageView = (ImageView)convertView.findViewById(R.id.image_view_list_view); holder.textView = (TextView)convertView.findViewById(R.id.text_view_list_view); convertView.setTag(holder); } ...... } 但是，随之而来的问题是：图片异步加载时可能会导致的错乱问题。当第一个图片在后台线程进行加载时（可能是网络下载），在还没有下载完成的时候，我们对listview进行滚动，这个时候的item的view是复用的，所以当图片加载完成后，会将图片设置到后面的某个item里。 解决方法：通过给imageView设置tag（将tag设置为uri），在设置图片时，进行比较，不等的设置为默认值。 ImageView imageView = holder.imageView; String tag = (String) imageView.getTag(); String url = items.get(position).getUrl(); if (!url.equals(tag)) { imageView.setImageDrawable(mDefaultBitmapDrawable); } imageView.setTag(url); imageLoader.bindBitmap(url, imageView, 100, 100); RecyclerView类似的 public void onBindViewHolder(ViewHolder holder, int position) { String tag = (String) holder.imageView.getTag(); if (!items.get(position).getUrl().equals(tag)) { } holder.imageView.setTag(items.get(position).getUrl()); imageLoader.bindBitmap(items.get(position).getUrl(), holder.imageView, 500, 500); }]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android常用工具包]]></title>
    <url>%2F2016%2F10%2F07%2Fandroid%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Github地址https://github.com/wz-wilbertwu/android-util 包含AppUtilBitmapLoadBitmapLruCacheDiskLruCacheDownloadUtilFileUtiImageLoaderImageResizerLogUtiMd5Util]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntentService简介及简单使用]]></title>
    <url>%2F2016%2F10%2F07%2FIntentService%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用 创建类继承IntentService public class CustomIntentService extends IntentService { /** * Creates an IntentService. Invoked by your subclass&apos;s constructor. * */ public CustomIntentService() { super(&quot;custom intent service&quot;); } @Override protected void onHandleIntent(Intent intent) { LogUti.d(&quot;on handle intent&quot;); LogUti.d(intent.getStringExtra(&quot;key&quot;)); SystemClock.sleep(6000); LogUti.d(&quot;after 6000ms&quot;); } } 在manifest中定义service &lt;service android:name=&quot;custome_service.CustomIntentService&quot;&gt;&lt;/service&gt; 在activity中启动IntentService findViewById(R.id.btn_start_intent_service).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(IntentServiceActivity.this, CustomIntentService.class); intent.putExtra(&quot;key&quot;, &quot;value&quot;); startService(intent); } 启动服务之后调用的是onHandleIntent方法注意onHandleIntent方法不运行在UI线程所以没有办法进行界面的操作：例如toast显示结果如下图 IntentService与Activity进行交互通过本地广播的方式进行 在IntentService中 Intent localIntent = new Intent(CustomConstans.BROADCAST_ACTION); localIntent.putExtra(CustomConstans.BROADCAST_KEY, &quot;from intent service&quot;); LocalBroadcastManager.getInstance(this).sendBroadcast(localIntent); 在Activity中 新建类继承broadcastreceiver private class ResponseReceive extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context, intent.getStringExtra(CustomConstans.BROADCAST_KEY) , Toast.LENGTH_SHORT).show(); } } 注册广播 IntentFilter intentFilter = new IntentFilter(CustomConstans.BROADCAST_ACTION); ResponseReceive responseReceive = new ResponseReceive(); LocalBroadcastManager.getInstance(this).registerReceiver(responseReceive, intentFilter); tips onHandleIntent方法运行在后台线程，无法进行界面操作。 通过本地广播的方式来跟activity进行交互。 Work requests run sequentially. If an operation is running in an IntentService, and you send it another request, the request waits until the first operation is finished.顺序执行]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试一些知识点]]></title>
    <url>%2F2016%2F10%2F03%2F%E9%9D%A2%E8%AF%95%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service]]></title>
    <url>%2F2016%2F09%2F26%2FService%2F</url>
    <content type="text"><![CDATA[Service基本用法和Activity进行通信 继承Binder对象 public class DownloadBinder extends Binder{ int count = 0; Handler handler; public void setHandler(Handler handler) { this.handler = handler; } public void startDownload() { } } 继承Service，Override onBind函数,新增成员：DownloadBinder。 public class MyService extends Service { DownloadBinder downloadBinder = new DownloadBinder(); @Nullable @Override public IBinder onBind(Intent intent) { return downloadBinder; } } Activity中，连接时获得DownloadBinder实例，这样就可以通过Binder来与Service进行通信。 ServiceConnection connection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { binder = (MyService.DownloadBinder) service; binder.setHandler(handler); binder.startDownload(); } @Override public void onServiceDisconnected(ComponentName name) { }}; 绑定service Intent intent = new Intent(ServiceLearnActivity.this, MyService.class); bindService(intent, connection, BIND_AUTO_CREATE); 生命周期 startService方法调用时，启动相应的服务，如果服务之前没有创建，那么会先回调onCreate方法，接下来回调onStartCommand方法。 每个服务只会存在一个实例。 bindService方法：回调onBind方法：如果服务之前还没有创建，那么会先回调onCreate方法。]]></content>
      <tags>
        <tag>android</tag>
        <tag>第一行代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity]]></title>
    <url>%2F2016%2F09%2F26%2FActivity%2F</url>
    <content type="text"><![CDATA[Activityres目录 drawable 存放图片 R.drawable.XXX @drawable/XXX values 存放字符串 代码中：R.string.XXX xml中：@string/XXX layout 存放布局文件 menu 存放菜单文件 项目中任何添加的资源都会在R文件中生成一个相应的资源id。 添加菜单 res下新建menu文件夹，添加菜单文件（res的menu文件夹中） 重写onCreateOptionsMenu方法 @Override public boolean onCreateOptionsMenu(Menu menu) { this.getMenuInflater().inflate(R.menu.main, menu); return true; } 响应点击按钮事件 @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.set_item: Toast.makeText(this, &quot;设置&quot;, Toast.LENGTH_SHORT).show(); } return true; } Intent隐式intent待启动的activity 在需要响应内容的Activity中添加action以及category字段，只有当这两个字段完全匹配上intent的相应的值时，才可以启动activity。 intent构造函数：action字符串传入，默认情况下会插入 “android.intent.category.DEFAULT” intent-filter可以指定data标签，更精确的指定当前activity能够响应的数据 &lt;data android:scheme=&quot;http&quot; android:mimeType=&quot;XXX&quot;&gt;&lt;/data&gt; 除此之外，还能够匹配host，port，path等，只有当这些值完全匹配，才会被启动。 隐式启动activity时 intent 可以指定多个category Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;)); Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(&quot;tel:10086&quot;)); intent setDateAndType（，）两个参数分别是uri以及文件类型.http://blog.csdn.net/chaoyu168/article/details/50778016activity之间传递数据 传递给下一个界面 在intent当中putExtra就可以了,在下一个界面当中getIntent获得intent就可以读取里面的内容了。 可以直接使用key-value的方式插入intent中，也可以通过bundle类来进行插入，bundle类类似一个map，能够简化操作。 实现了序列化接口的类对象也可以通过intent传递。 对接时怎么样传递数据比较好呢？ 在被启动的页面中新增一个静态方法actionStart(),参数需要有context，然后参数列表是需要传递的数据，这样在前一个页面中直接调用这个方法就可以启动新的页面了。 startActivityForResult 启动时传入requestCode 重写onActivityResult方法，根据参数中的requestCode判断是哪个的回调。 必要时还需要重写被启动页面的返回键回调函数onBackPress() 生命周期 Activity被回收了 onSaveInstanceState(Bundle) onCreate(Bundle) 启动模式 standard模式 singleTop模式 栈顶如果是要启动的activity，则不新建，仅此而已。 singleTask模式 检查返回栈中是否存在类的实例，如果存在将其上的所有activity出栈。 singleInstance模式 存放在一个新的返回栈里面。]]></content>
      <tags>
        <tag>android</tag>
        <tag>第一行代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View]]></title>
    <url>%2F2016%2F09%2F26%2FView%2F</url>
    <content type="text"><![CDATA[追踪手指在滑动过程中的速度@Override public boolean onTouchEvent(MotionEvent event) { VelocityTracker velocityTracker = VelocityTracker.obtain(); velocityTracker.addMovement(event); velocityTracker.computeCurrentVelocity(1000); int x = (int)velocityTracker.getXVelocity(); int y = (int)velocityTracker.getYVelocity(); Log.d(W, &quot;x:&quot; + x + &quot;,y:&quot; + y); return super.onTouchEvent(event); } 检测手势行为implements GestureDetector.OnGestureListener @Override public boolean onTouchEvent(MotionEvent event) { boolean consume = gestureDetector.onTouchEvent(event); return consume; } 滑动scrollTo&amp;&amp;scrollerBy使用动画改变布局参数public void onClick(View v) { ViewGroup.MarginLayoutParams marginLayoutParams = (ViewGroup.MarginLayoutParams)button.getLayoutParams(); Log.d(W, &quot;layout&quot;); marginLayoutParams.width += 100; marginLayoutParams.leftMargin += 100; button.requestLayout(); }]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI]]></title>
    <url>%2F2016%2F09%2F26%2FUI%2F</url>
    <content type="text"><![CDATA[TextView android:gravity top bottom left right等等，指定对齐方向 match_parent fill_parent wrap_content EditTextmaxLine ImageViewimageView.setImageResource(R.mipmap.abc); visible invisible gone属性 visible 可见 invisible 不可见但是还存在 gone 不可见不存在 View setVisibilty() View.gone … AlertDialog AlertDialog.Builder builder = new AlertDialog.Builder(UIActivity.this); builder.setTitle(&quot;AlertDialogTitle&quot;); builder.setCancelable(false); builder.setMessage(&quot;some message&quot;); builder.setPositiveButton(&quot;Yes&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { } }); builder.setNegativeButton(&quot;No&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { } }); builder.show(); LinearLayout 指定方向，要注意如果是水平方向的话，则内部控件的宽度不能够是match_parent的不然会充满整个布局，同理竖直方向也是类似的。 android:layout_gravity属性：正如TextView中gravity表示文本内容占据整个宽度的位置，这个属性指的是控件在LinearLayout中的相对位置，而且，当外层layout是竖直布局时在其上的关于竖直的设置是不会生效的。注意，这个属性亦是属于子布局里面的而不是属于LinearLayout（要指定的是每一个不同的子布局）。 android:layout_weight属性：系统会先把 LinearLayout 下所有控件指定的 layout_weight 值相加， 得到一个总值，然后每个控件所占大小的比例就是用该控件的 layout_weight 值除以刚才算出的总值。 布局中的如果只有部分控件有weight属性，则有weight属性的控件共享剩下的宽度或者高度（按照比例分配）。 RelativeLayout 相对布局dp和sp在编写 Android 程序的时候，尽量将控件或布局的大小指定成 match_parent或 wrap_content，如果必须要指定一个固定值，则使用 dp 来作为单位，指定文字大小的时候使用 sp 作为单位。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔试题目]]></title>
    <url>%2F2016%2F09%2F26%2FAndroid%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[title: Android基础笔试题tags: android 笔试activity的启动过程 onCreate()-&gt;onStart()-&gt;onResume()-&gt;运行-&gt;onPause()-&gt;onStop()-&gt;onDestroy. 注意，当启动新的activity或切换到桌面时，回调onPause和onStop，切换回来的时候，回调onRestart-&gt;onStart-&gt;onResume。 back回退时，回调onPause，onStop，onDestroy。 如果被系统回收的话，则与初次启动回调函数一样，但是在onCreate中会有个状态保存的变量供恢复数据 旧Activity的onPause先调用，然后新Activity才启动。 意外情况activity被销毁的时候，会调用onSaveInstanceState保存状态，再将Bundle对象传递给onRestoreInstanceState和onCreate方法。 资源内存不足导致activity被杀死 优先级：前台&gt;可见但非前台（弹出对话框的activity）&gt;后台（已经被暂停的） activity的启动模式有 标准模式 singleTop 栈顶复用模式，如果在栈顶，则不重新创建，同时调用onNewIntent方法 singleTask 栈内复用,在一个新的task中产生这个实例，以后每次调用都会使用这个。 singleInstance 单实例模式，与singleTask模式基本一样，区别在于在这个模式下的activity实例所处的task中只有这个实例而不会有其他的实例。 数据存储方式 sharedpreferrence：xml格式，简单的键值对，有缓存，注意多线程访问时候可能出现的问题 普通文件存储 SQLite数据库：轻量级的数据库，使用openHelper，cursor，SQLiteDataBase。 ContentProvider。cursor，provider。 网络。httpURLconnection。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广播接收器]]></title>
    <url>%2F2016%2F09%2F26%2Fbroadcast%2F</url>
    <content type="text"><![CDATA[广播机制 标准广播 完全异步执行 所有广播接收器几乎同时收到 有序广播 同步执行 优先级高的先收到，可以截断。 系统广播 broadcast receiver 不允许开启线程 onReceive 中的context的来源，是谁在调用这个函数 // todo 静态注册 manifest中注册 &lt;intent-filter&gt; &lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;&gt;&lt;/action&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 动态注册 代码中注册 继承类 class NetworkChangeReceiver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { ConnectivityManager manager = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE); NetworkInfo info = manager.getActiveNetworkInfo(); /* Intent intent1 = new Intent(context, SettingActivity.class); startActivity(intent1); */ if (info != null &amp;&amp; info.isAvailable()) { Toast.makeText(context, &quot;network is available&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(context, &quot;network is unavailable&quot;, Toast.LENGTH_SHORT).show(); } } } 注册广播，在onCreate中添加 IntentFilter intentFilter = new IntentFilter(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;); registerReceiver(receiver, intentFilter); 注意要在onDestroy函数中取消注册。 自定义广播接收器 与隐式intent类似，可以在intent-filter中添加自定义的action，发送广播时调用sendBroadCast(Intent intent)。此时发送的是标准广播，同时也可以发送一些数据，在intent当中。 sendOrderedBroadCast() 发送有序广播 本地广播功能LocalBroadCastManager getInstance()方法 初始化localBroadCastManager localBroadCastManager = LocalBroadCastManager.getInstance(this); 注册 localBroadCastManager.register….. 发送 localBroadCastManager.send…… 销毁 localBroadCastManager .unregister….. 本地广播无法使用静态注册。 tips 在广播接收器里启动activity时，需要给Intent加入FLAG_ACTIVITY_NEW_TASK标志。]]></content>
      <tags>
        <tag>android</tag>
        <tag>第一行代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecycleView]]></title>
    <url>%2F2016%2F09%2F26%2FRecycleView%2F</url>
    <content type="text"><![CDATA[创建RecycleView.Adapter的继承类 其中存在内部静态类：继承 RecyclerView.ViewHolder. 内部静态类： public static class ViewHolder extends RecyclerView.ViewHolder{ public Button button; public ViewHolder(View t) { super(t); button = (Button) t.findViewById(R.id.item_text_view); }} 重载函数 onCreateViewHolder @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { final View view = LayoutInflater.from(parent.getContext()) .inflate(R.layout.my_text_view, parent, false); ViewHolder viewHolder = new ViewHolder(view); return viewHolder; } 重载onBindViewHolder，设置每一个item的内容 @Override public void onBindViewHolder(ViewHolder holder, int position) { //每个item的具体设置 holder.button.setText(dataSet.get(position)); } 实现按钮监听的方法 声明接口 public interface IOnItemClick { void onItemClick(View view); } 在Activity中实现接口 MenuAdapter.IOnItemClick iOnItemClick = new MenuAdapter.IOnItemClick() { @Override public void onItemClick(View view) { //此处的view为每个item的View而非里面的按钮之类的 int itemPosition = recyclerView.getChildLayoutPosition(view); } } 在初始化Adapter中，将接口的实现类传进去。 在Adapter中。 @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { final View view = LayoutInflater.from(parent.getContext()) .inflate(R.layout.my_text_view, parent, false); ViewHolder viewHolder = new ViewHolder(view); if(iOnItemClick != null) { viewHolder.button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { iOnItemClick.onItemClick(view); //此处调用的view为上面所述的view而非按钮v } }); } return viewHolder; }]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步消息处理]]></title>
    <url>%2F2016%2F09%2F26%2FHandler_async_task%2F</url>
    <content type="text"><![CDATA[HandlerHandler的使用 继承Handler类，Override它的handleMessage方法（处理消息） Handler handler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); textView.setText(&quot;after handling&quot; + msg.getData().getString(&quot;key&quot;)); } }; tips:Message可能需要用到的两个成员分别是 msg.what msg.setData(),msg.getData() 在新开的线程中使用handler的sendMessage方法发送消息，以达到修改UI元素的效果。 new Thread(new Runnable() { @Override public void run() { Message msg = new Message(); Bundle bundle = new Bundle(); bundle.putString(&quot;key&quot;, textView.getText().toString()); msg.setData(bundle); handler.sendMessage(msg); } }).start(); 一些思考 MessageQueue：消息队列 Looper：循环，一直从消息队列中获得消息，如果没有消息则一直循环。成员变量有MessageQueue。ThreadLocal变量，每个线程唯一且相同。 Handler：成员变量有Looper，亦即也拥有MessageQueue，发送消息时向消息队列插入消息，有Looper负责发现消息并且根据Message的target（亦即handler）来负责处理消息。 * 所以，当我们在子线程中用handler发送消息时，插入的MessageQueue是主线程的MessageQueue，此时由handler的操作便变成了主线程的操作而非在子线程中操作界面。 AsyncTask 继承AsyncTask类 //参数，运行时返回值类型，结果类型 class DownloadTask extends AsyncTask&lt;String, Integer, Boolean&gt; { int count = 0; //任务启动前执行的函数 @Override protected void onPreExecute() { progressDialog.show(); } //后台执行的函数，可以进行耗时操作 @Override protected Boolean doInBackground(String... params) { while (true) { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } count++; if (count &gt;= 10) { break; } //这个方法会调用更新进度显示的函数。 publishProgress(count); } return true; } //更新进度显示 @Override protected void onProgressUpdate(Integer... values) { progressDialog.setMessage(&quot;downloaded &quot; + values[0]*10 + &quot;%&quot;); } //后台执行完成之后调用。 @Override protected void onPostExecute(Boolean aBoolean) { progressDialog.dismiss(); if(aBoolean) { Toast.makeText(MessageHandleActivity.this, &quot;succeed&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(MessageHandleActivity.this, &quot;failed&quot;, Toast.LENGTH_SHORT).show(); } } }]]></content>
      <tags>
        <tag>android</tag>
        <tag>第一行代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIDL]]></title>
    <url>%2F2016%2F09%2F26%2FAIDL%2F</url>
    <content type="text"><![CDATA[Aidl:android interface definition languageaidl是安卓中一种跨进程通信的方式。 服务端 创建一个service来监听客户端的连接请求 创建aidl文件，声明将要供客户端使用的接口以及方法 在service中实现接口方法。客户端 绑定服务端的service 将服务端返回的Binder对象转化成AIDL接口的类型 那么我们就能够在客户端中实现调用AIDL的方法了。（跨进程方法调用）]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于handler以及一些回调的思考]]></title>
    <url>%2F2016%2F06%2F23%2F%E5%85%B3%E4%BA%8Ehandler%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9B%9E%E8%B0%83%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[有线程如下： public class SetTextThread extends Thread { private IIsetText iIsetText; private Handler handler; private MyNum myNum; public SetTextThread(IIsetText iIsetText) { this.iIsetText = iIsetText; } public SetTextThread(Handler handler) { this.handler = handler; } public SetTextThread(MyNum myNum) { print(&quot;constructor:&quot; + Thread.currentThread()); this.myNum = myNum; } @Override public void run() { print(&quot;run:&quot; + Thread.currentThread()); // iIsetText.setText(); // handler.sendMessage(new Message()); myNum.i = 9999; } public void print(String s) { System.out.println(s); } } 多线程中，变量虽然相同，但是其实他们指向的是不同的内存区域，所以修改是不会影响到互相的值的。//此处有待确认正确与否，待查看thinking in java后再行确定。 handler中，首先要先了解handler的消息机制 MessageQueue：消息队列 Looper：循环，一直从消息队列中获得消息，如果没有消息则一直循环。成员变量有MessageQueue。ThreadLocal变量，每个线程唯一且相同。 Handler：成员变量有Looper，亦即也拥有MessageQueue，发送消息时向消息队列插入消息，有Looper负责发现消息并且根据Message的target（亦即handler）来负责处理消息。 所以，当我们在子线程中用handler发送消息时，虽然说此时的handler是另外线程中主线程handler的复制品，但是内容是完全一样的，亦即其Looper与消息队列依然是主线程的，所以，当发送消息时，插入的MessageQueue依旧是主线程，此时由handler的操作便变成了主线程的操作而非在子线程中操作界面。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[helloworld]]></title>
    <url>%2F2016%2F06%2F23%2F%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[android面试题目Service Activity中 void initData() { mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { myBinder = (MyBinder)service; myBinder.showMessage(); } @Override public void onServiceDisconnected(ComponentName name) { SomeMethod.makeToast(ServiceActivity.this, &quot;service disconnected&quot;); } }; } public void onClick(View v) { Intent intent = null; switch (v.getId()) { case R.id.startSerBtn: intent = new Intent(this, MyService.class); startService(intent); break; case R.id.endSerBtn: intent = new Intent(this, MyService.class); stopService(intent); break; case R.id.bindBtn: intent = new Intent(this, MyService.class); bindService(intent, mConnection, BIND_AUTO_CREATE); isBind = true; break; case R.id.unBinBtn: if (isBind) { unbindService(mConnection); isBind = false; } break; } } } MyBinder类 public class MyBinder extends Binder { Context mContext; public MyBinder(Context context) { mContext = context; } public void showMessage() { SomeMethod.makeToast(mContext, &quot;in myBinder&quot;); } } MyService类 public class MyService extends Service { public static final String w = &quot;wilbert&quot;; @Override public void onCreate() { super.onCreate(); SomeMethod.makeToast(this, &quot;onCreate&quot;); Log.d(w, &quot;onCreate&quot;); myBinder = new MyBinder(this); } @Override public int onStartCommand(Intent intent, int flags, int startId) { Log.d(w, &quot;onStartCommand&quot;); SomeMethod.makeToast(this, &quot;onStartCommand&quot;); return super.onStartCommand(intent, flags, startId); } @Override public void onDestroy() { SomeMethod.makeToast(this, &quot;onDestroy&quot;); Log.d(w, &quot;onDestroy&quot;); super.onDestroy(); } MyBinder myBinder; @Nullable @Override public IBinder onBind(Intent intent) { Log.d(w, &quot;onBind&quot;); return myBinder; } } 数据库 OpenHelper package com.wilbert.firstlinecode.DB; import android.content.Context; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteOpenHelper; import android.widget.Toast; /** * Created by wilbert on 2016/4/15. */ public class DbOpenHelper extends SQLiteOpenHelper { public static final String CREATE_BOOK = &quot;create table book (&quot; + &quot;id integer primary key autoincrement, &quot; + &quot;author text, &quot; + &quot;price real, &quot; + &quot;pages integer, &quot; + &quot;name text)&quot;; public static final String CREATE_CATEGORY = &quot;create table Category (&quot; + &quot;id integer primary key autoincrement, &quot; + &quot;category_name text, &quot; + &quot;category_code integer)&quot;; private Context mContext; public DbOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) { super(context, name, factory, version); mContext = context; } @Override public void onCreate(SQLiteDatabase db) { db.execSQL(CREATE_BOOK); db.execSQL(CREATE_CATEGORY); Toast.makeText(mContext, &quot;create db successfully&quot;, Toast.LENGTH_SHORT).show(); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } } SqlActivity public class SqlActivity extends BaseActivity { Button createDbBtn; Button insertBtn; Button updateBtn; Button deleteBtn; ListView sqlListview; DbOpenHelper dbOpenHelper; SQLiteDatabase sqLiteDatabase; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;(); ArrayAdapter&lt;String&gt; arrayAdapter; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_sql); initView(); initData(); Log.v(&quot;w&quot;, &quot;onCreate&quot;); } @Override void initView() { createDbBtn = (Button)findViewById(R.id.createDbBtn); createDbBtn.setOnClickListener(this); insertBtn = (Button)findViewById(R.id.insertBtn); insertBtn.setOnClickListener(this); updateBtn = (Button)findViewById(R.id.updateBtn); updateBtn.setOnClickListener(this); deleteBtn = (Button)findViewById(R.id.deleteBtn); deleteBtn.setOnClickListener(this); sqlListview = (ListView)findViewById(R.id.dbListview); } @Override void initData() { dbOpenHelper = new DbOpenHelper(this, &quot;BookStore&quot;, null, 1); sqLiteDatabase = dbOpenHelper.getWritableDatabase(); readDataFromSql(); arrayAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1 , stringList); sqlListview.setAdapter(arrayAdapter); } private void readDataFromSql() { stringList.clear(); Cursor cursor = sqLiteDatabase.query(Book.TABLE_NAME, null, null, null, null, null, null); if (cursor.moveToFirst()) { do { stringList.add(Book.getBookFromCursor(cursor).toString()); } while (cursor.moveToNext()); } } @Override public void onClick(View v) { switch (v.getId()) { case R.id.createDbBtn: dbOpenHelper.getWritableDatabase(); break; case R.id.insertBtn: Book book = new Book(&quot;wilbert&quot;, &quot;mybook&quot;, 99, 100); long id = sqLiteDatabase.insert(Book.TABLE_NAME, null, book.makeContenValues()); if (id != -1) { Toast.makeText(this, &quot;insert successfully&quot;, Toast.LENGTH_SHORT).show(); } break; case R.id.updateBtn: Book book2 = new Book(&quot;wilbert&quot;, &quot;mybook&quot;, 50, 100); int effects = sqLiteDatabase.update(Book.TABLE_NAME, book2.makeContenValues(), &quot;name = ?&quot;, new String[]{&quot;mybook&quot;}); if (effects != 0) { Toast.makeText(this, &quot;update successfully&quot;, Toast.LENGTH_SHORT).show(); } break; case R.id.deleteBtn: // sqLiteDatabase.beginTransaction(); int i = sqLiteDatabase.delete(Book.TABLE_NAME, &quot;pages &gt; ? OR name = ?&quot;, new String[]{&quot;10&quot;, &quot;wilbert&quot;}); if (i != 0) { showToasts(i + &quot; delete successfully&quot;); } // sqLiteDatabase.endTransaction(); break; } readDataFromSql(); arrayAdapter.notifyDataSetChanged(); } private void showToasts(String s) { Toast.makeText(this, s, Toast.LENGTH_SHORT).show(); } } ContentProvider contentProvider类 package com.wilbert.firstlinecode.model; import android.content.ContentProvider; import android.content.ContentValues; import android.content.UriMatcher; import android.database.Cursor; import android.database.sqlite.SQLiteDatabase; import android.net.Uri; import android.support.annotation.Nullable; import com.wilbert.firstlinecode.DB.DbOpenHelper; import java.net.Inet4Address; /** * Created by wilbert on 2016/4/15. */ public class BookProvider extends ContentProvider { public static final int BOOK_DIR = 0; public static final int BOOK_ITEM = 1; public static final String AUTHORITY = &quot;com.example.databasetest.provider&quot;; private static UriMatcher uriMatcher; private DbOpenHelper dbOpenHelper; private SQLiteDatabase sqLiteDatabase; static { uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_DIR); uriMatcher.addURI(AUTHORITY, &quot;book/# &quot;, BOOK_ITEM); } @Override public boolean onCreate() { dbOpenHelper = new DbOpenHelper(getContext(), &quot;BookStore&quot;, null, 1); sqLiteDatabase = dbOpenHelper.getWritableDatabase(); return true; } @Nullable @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { Cursor cursor = null; switch (uriMatcher.match(uri)) { case BOOK_DIR: cursor = sqLiteDatabase.query(&quot;Book&quot;, projection, selection, selectionArgs, null, null, sortOrder); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); cursor = sqLiteDatabase.query(&quot;Book&quot;, projection, &quot;id = ?&quot;, new String[] {bookId}, null, null, sortOrder); break; } return cursor; } @Nullable @Override public String getType(Uri uri) { switch (uriMatcher.match(uri)) { case BOOK_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book&quot;; case BOOK_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.book&quot;; } return null; } @Nullable @Override public Uri insert(Uri uri, ContentValues values) { Uri returnUri = null; switch (uriMatcher.match(uri)) { case BOOK_DIR: case BOOK_ITEM: long newBookId = sqLiteDatabase.insert(&quot;Book&quot;, null, values); returnUri = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book/&quot; + newBookId); break; } return returnUri; } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { int deletedRows = 0; switch (uriMatcher.match(uri)) { case BOOK_DIR: deletedRows = sqLiteDatabase.delete(&quot;Book&quot;, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); deletedRows = sqLiteDatabase.delete(&quot;Book&quot;, &quot;id = ?&quot;, new String[] { bookId }); break; } return deletedRows; } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { int updatedRows = 0; switch (uriMatcher.match(uri)) { case BOOK_DIR: updatedRows = sqLiteDatabase.update(&quot;Book&quot;, values, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); updatedRows = sqLiteDatabase.update(&quot;Book&quot;, values, &quot;id = ?&quot;, new String[] {bookId}); break; } return updatedRows; } } provider activity public void onClick(View v) { // TODO: 2016/4/15 query operation cursor String newId; switch (v.getId()) { case R.id.queryBtn: Uri uri2 = Uri.parse(&quot;content://com.example.databasetest.provider/book/1&quot;); Cursor cursor = getContentResolver().query(uri2, null, null, null, null); if (cursor != null) { Book book = Book.getBookFromCursor(cursor); stringList.add(book.toString()); arrayAdapter.notifyDataSetChanged(); } break; case R.id.insertBtn: Uri uri = Uri.parse(&quot;content://com.example.databasetest.provider/book&quot;); Book book = new Book(&quot;wilbdd&quot;, &quot;nae&quot;, 100, 100); Uri newUri = getContentResolver().insert(uri, book.makeContenValues()); //newId = newUri.getPathSegments().get(1); makeToast(&quot; &quot; + &quot;insert&quot;); makeToast(newUri.toString()); break; } }]]></content>
      <tags>
        <tag>android面试题目</tag>
      </tags>
  </entry>
</search>
