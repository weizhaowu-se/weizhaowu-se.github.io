<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[minio时间问题及docker时区修改]]></title>
    <url>%2F2020%2F09%2F01%2Fminio%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98%E5%8F%8Adocker%E6%97%B6%E5%8C%BA%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[minio时间问题及docker时区修改问题描述 The difference between the request time and the current time is too large 问题背景 通过docker部署的minio 通过docker部署的springboot应用 centos - 7.5 解决方式 修改容器的时区 minio是通过docker run命令启动的，所以只需要添加下启动参数-v /etc/localtime:/etc/localtime即可（这一步是将容器的时区和宿主机的时区设置为一致） springboot是通过DockerFile打包启动的，在DockerFile中添加RUN ln -sf /usr/share/zoneinfo/Asia/ShangHai /etc/localtime即可 在修改完时区之后，可以通过命令date -R查看具体时间和时区 注意，在时区一致的情况下，如果宿主机的时间有错的话，也会导致不能够解决问题，这个时候我们需要修改宿主机的时间，有两种方式进行修改 date -s &#39;2020-09-01 00:00:00&#39; 或者通过其他在线的时钟同步方式进行时间同步]]></content>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch之文本导入及拼音搜索实现]]></title>
    <url>%2F2020%2F08%2F16%2Felasticsearch%E4%B9%8B%E6%96%87%E6%9C%AC%E5%AF%BC%E5%85%A5%E5%8F%8A%E6%8B%BC%E9%9F%B3%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[elasticsearch之文本导入及拼音搜索实现需求：非结构化数据（word，pdf等文档）导入es，实现全文检索的功能（包括拼音检索功能） 本文会先从非结构化数据导入es，还有拼音搜索的实现，以及最后两者的联合应用。 本文基于es版本6.8.0 非结构化数据的导入 插件：ingest-attachment 版本：6.8.0 步骤 建立文本抽取管道（执行时需将//注释内容去掉） 12345678910111213141516PUT /_ingest/pipeline/attachment //atttachment为管道名称，下文导入数据时会使用&#123; &quot;description&quot;: &quot;Extract attachment information&quot;, &quot;processors&quot;: [ &#123; &quot;attachment&quot;:&#123; &quot;field&quot;:&quot;data&quot;, //管道抽取使用的原数据字段 &quot;indexed_chars&quot; : -1, &quot;ignore_missing&quot;:true &#125; &#125;, &#123; &quot;remove&quot;:&#123;&quot;field&quot;:&quot;data&quot;&#125; //抽取完成是否要删除原字段 &#125; ]&#125; 建索引（此处略去，不需要限定字段类型的话可以直接使用默认生成的索引结构） 将想要导入的数据转成base64 此处我使用的是mac自带的base64命令 1base64 -i 输入文件 -o 输出文件 导入数据 1234PUT /pdftest/pdf/1?pipeline=attachment&#123; &quot;data&quot;:&quot;5oiR54ix5L2g&quot;&#125; 查询数据 1234567891011121314151617181920212223242526272829//查询命令GET /pdftest/pdf/1//查询结果&#123; &quot;_index&quot; : &quot;pdftest&quot;, &quot;_type&quot; : &quot;pdf&quot;, &quot;_id&quot; : &quot;1&quot;, &quot;_version&quot; : 4, &quot;_seq_no&quot; : 3, &quot;_primary_term&quot; : 3, &quot;found&quot; : true, &quot;_source&quot; : &#123; &quot;attachment&quot; : &#123; //attachment里面的其他字段可以通过配置管道的时候进行配置 &quot;content_type&quot; : &quot;text/plain; charset=UTF-8&quot;, &quot;language&quot; : &quot;lt&quot;, &quot;content&quot; : &quot;我爱你&quot;, //content内容即为文本转换的内容 &quot;content_length&quot; : 4 &#125; &#125;&#125;//查询命令POST /pdftest/_search&#123; &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;attachment.content&quot;: &quot;我爱&quot; &#125; &#125;&#125; 参考https://www.elastic.co/guide/en/elasticsearch/plugins/6.8/ingest-attachment.html#ingest-attachment https://blog.csdn.net/wenxindiaolong061/article/details/82562450 https://blog.csdn.net/m0_37739193/article/details/86421246 https://stackoverflow.com/questions/37861279/how-to-index-a-pdf-file-in-elasticsearch-5-0-0-with-ingest-attachment-plugin https://blog.csdn.net/LazyBoy_Z_z/article/details/82864264 拼音搜索的实现 插件：https://github.com/medcl/elasticsearch-analysis-pinyin 版本：6.8.0 步骤 自定义分词器 要使用「拼音插件」需要在创建索引时使用「自定义模板」并在自定义模板中「自定义分析器」。 123456789101112131415161718192021222324252627PUT /doc_resources&#123; &quot;settings&quot;: &#123; &quot;analysis&quot;: &#123; &quot;analyzer&quot;: &#123; &quot;user_name_analyzer&quot;: &#123; &quot;tokenizer&quot;: &quot;ik_smart&quot;, &quot;filter&quot;: &quot;pinyin_first_letter_and_full_pinyin_filter&quot; &#125; &#125;, &quot;filter&quot;: &#123; &quot;pinyin_first_letter_and_full_pinyin_filter&quot;: &#123; //此处的配置可以参见github上插件说明页的可选项配置 &quot;type&quot;: &quot;pinyin&quot;, &quot;keep_first_letter&quot;: true, &quot;keep_full_pinyin&quot;: true, &quot;keep_none_chinese&quot;: true, &quot;keep_original&quot;: true, &quot;limit_first_letter_length&quot;: 16, &quot;lowercase&quot;: true, &quot;trim_whitespace&quot;: true, &quot;keep_none_chinese_in_first_letter&quot;: true, &quot;ignore_pinyin_offset&quot;: true &#125; &#125; &#125; &#125;&#125; 创建索引mapping 123456789101112131415161718POST /doc_resources/doc/_mapping&#123; &quot;properties&quot;: &#123; &quot;doc_name&quot;: &#123; //字段名称 &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_smart&quot;, //指定该字段为ik_smart分词 &quot;fields&quot;: &#123; &quot;pinyin&quot;: &#123; //子pinyin字段 &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: false, &quot;term_vector&quot;: &quot;with_offsets&quot;, &quot;analyzer&quot;: &quot;user_name_analyzer&quot;, //指定为第一步的自定义拼音分词方式 &quot;boost&quot;: 10 &#125; &#125; &#125; &#125; &#125; 导入数据 1234PUT /doc_resources/doc/1/&#123; &quot;doc_name&quot;: &quot;因他“是香港最受尊重和喜爱的演艺名人之一，对香港电影及音乐贡献良多。其严谨专业的工作态度，足以成为年轻人的典范”，为了“表彰他在表演艺术方面的成就”而授予刘德华荣誉院士称号，&quot;&#125; 在拼音字段上面做检索 12345678POST /doc_resources/_search&#123; &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;doc_name.pinyin&quot;: &quot;liudehua&quot; &#125; &#125;&#125; 查看分词的结果 12345POST /doc_resources/_analyze&#123; &quot;analyzer&quot;: &quot;user_name_analyzer&quot;, &quot;text&quot;: [&quot;刘德华&quot;]&#125; 参考https://github.com/medcl/elasticsearch-analysis-pinyin https://symonlin.github.io/2019/01/07/elasticsearch-4/ 联合使用接下来我们要将上面两个结合起来，使用非结构化文本导入&amp;&amp;拼音检索 其实很简单，通过拼音的检索的配置流程我们可以看到，是将pinyin字段作为单独的一个子字段进行存放并且指定分词器为拼音分词器，那么一样的，只要预先定义好索引的结构（我们在非结构化数据导入的时候并没有定义好结构而是让es在导入数据的时候默认生成了），那么就能够实现拼音的效果了，定义的索引结构如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849PUT /doc_resources/doc/_mapping&#123; &quot;doc&quot;: &#123; &quot;properties&quot;: &#123; &quot;attachment&quot;: &#123; &quot;properties&quot;: &#123; &quot;content&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_smart&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125;, &quot;pinyin&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;store&quot;: false, &quot;term_vector&quot;: &quot;with_offsets&quot;, &quot;analyzer&quot;: &quot;user_name_analyzer&quot;, &quot;boost&quot;: 10 &#125; &#125; &#125;, &quot;content_length&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;, &quot;content_type&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125;, &quot;language&quot;: &#123; &quot;type&quot;: &quot;text&quot;, &quot;fields&quot;: &#123; &quot;keyword&quot;: &#123; &quot;type&quot;: &quot;keyword&quot;, &quot;ignore_above&quot;: 256 &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 导入非结构化数据 1234PUT /doc_resources/doc/2?pipeline=attachment&#123; &quot;data&quot;:&quot;5oiR54ix5L2g&quot;&#125; 查询数据 12345678910111213141516171819202122232425262728293031323334353637383940POST /doc_resources/_search&#123; &quot;query&quot;: &#123; &quot;match_phrase&quot;: &#123; &quot;attachment.content.pinyin&quot;: &quot;woaini&quot; &#125; &#125;&#125;//查询结果&#123; &quot;took&quot; : 5, &quot;timed_out&quot; : false, &quot;_shards&quot; : &#123; &quot;total&quot; : 5, &quot;successful&quot; : 5, &quot;skipped&quot; : 0, &quot;failed&quot; : 0 &#125;, &quot;hits&quot; : &#123; &quot;total&quot; : 1, &quot;max_score&quot; : 2.6894288, &quot;hits&quot; : [ &#123; &quot;_index&quot; : &quot;doc_resources&quot;, &quot;_type&quot; : &quot;doc&quot;, &quot;_id&quot; : &quot;2&quot;, &quot;_score&quot; : 2.6894288, &quot;_source&quot; : &#123; &quot;attachment&quot; : &#123; &quot;content_type&quot; : &quot;text/plain; charset=UTF-8&quot;, &quot;language&quot; : &quot;lt&quot;, &quot;content&quot; : &quot;我爱你&quot;, &quot;content_length&quot; : 4 &#125; &#125; &#125; ] &#125;&#125; 总结一下步骤流程 安装es，安装es插件（文本抽取，拼音分词） 设置管道属性（attachment pipeline） 设置指定索引的拼音分词器属性 创建该索引的mapping结构 文件转成base64，导入es 在pinyin分词字段上进行查询]]></content>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-binlog之主从同步]]></title>
    <url>%2F2020%2F06%2F17%2Fmysql-binlog%E4%B9%8B%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[mysql-binlog之主从同步基于上一篇我们已经在本地环境安装了两个mysql，这里我们来进行简单的配置来实现基于binlog的主从复制。 配置master数据库配置文件my.cnf 12345678910111213141516[mysqld]## 设置server_id，一般设置为IP,注意要唯一server_id=100## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）binlog-ignore-db=mysql## 开启二进制日志功能，可以随便取，最好有含义（关键就是这里了）log-bin=edu-mysql-bin## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M## 主从复制的格式（mixed,statement,row，默认格式是statement）binlog_format=mixed## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。expire_logs_days=7## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致slave_skip_errors=1062 由于mac上通过dmg安装的mysql默认没有这个配置文件，需要在/etc/下手动新建my.cnf 文件并配置如上 配置完成后重启mysql master创建用户用来进行同步操作 123CREATE USER &apos;slave&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &apos;slave&apos;@&apos;%&apos;; 配置slave数据库配置文件my.cnf 12345678910111213141516171819202122[mysqld]## 设置server_id，一般设置为IP,注意要唯一server_id=101## 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）binlog-ignore-db=mysql## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用log-bin=edu-mysql-slave1-bin## 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存binlog_cache_size=1M## 主从复制的格式（mixed,statement,row，默认格式是statement）binlog_format=mixed## 二进制日志自动删除/过期的天数。默认值为0，表示不自动删除。expire_logs_days=7## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致slave_skip_errors=1062## relay_log配置中继日志relay_log=edu-mysql-relay-bin## log_slave_updates表示slave将复制事件写进自己的二进制日志log_slave_updates=1## 防止改变数据(除了特殊的线程)read_only=1 由于是通过docker安装的，配置文件的位置和你的启动命令所映射到的本机的目录相关 配置主从同步 master中执行如下 1show master status; 需要记录的内容有 File Position slave中执行如下 1change master to master_host=&apos;host.docker.internal&apos;, master_user=&apos;slave&apos;, master_password=&apos;123456&apos;, master_port=3306, master_log_file=&apos;edu-mysql-bin.000001&apos;, master_log_pos=617, master_connect_retry=30; master_host：master对应的连接地址，此处填写docker容器访问宿主机的默认地址host.docker.internal master_log_file: 上面记录的File master_log_pos： 上面记录的Position 其他账号密码等信息 123start slave; ---启动主从复制stop slave; ---停止主从复制show slave status; ---显示slave状态 可以尝试建一个表/数据库来验证主从复制的过程。 参考 MySQL主从复制搭建，基于日志（binlog） 解决：Mac下mysql配置文件没有my-default.cnf，无法配置my.cnf Docker容器访问宿主机网络]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装mysql-5.7]]></title>
    <url>%2F2020%2F06%2F17%2Fdocker%E5%AE%89%E8%A3%85mysql-5-7%2F</url>
    <content type="text"><![CDATA[docker安装mysql-5.7 拉取镜像 1docker pull mysql:5.7 拉取成功 创建本地文件夹映射docker目录 123mkdir -p /Users/wilbert/docker/mysql-5.7/datamkdir -p /Users/wilbert/docker/mysql-5.7/logsmkdir -p /Users/wilbert/docker/mysql-5.7/conf 创建mysql配置文件my.cnf 12cd /Users/wilbert/docker/mysql-5.7/conftouch my.cnf 启动mysql 1docker run -p 4406:3306 --name mysql -v /Users/wilbert/docker/mysql-5.7/conf:/etc/mysql/conf.d -v /Users/wilbert/docker/mysql-5.7/logs:/logs -v /Users/wilbert/docker/mysql-5.7/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 各个命令解释如下 1234--name 为容器指定一个名称-v 将本地目录映射到docker内部目录中-p 端口映射-e 设置参数 由于我们已经指定了容器名称，所以我们后续要重启只需要执行如下命令即可 1docker start mysql 测试连接成功 参考 docker 安装 mysql5.7 Docker-端口映射 docker run和start的区别 docker笔记 - container name 冲突 Docker run 命令]]></content>
      <tags>
        <tag>docker</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下docker修改国内镜像源]]></title>
    <url>%2F2020%2F06%2F17%2Fmac%E4%B8%8Bdocker%E4%BF%AE%E6%94%B9%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90%2F</url>
    <content type="text"><![CDATA[mac下docker修改国内镜像源 打开Preferences配置 打开配置项 新增如下配置 123&quot;registry-mirrors&quot;: [ &quot;https://md4nbj2f.mirror.aliyuncs.com&quot; ]]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal及在多线程中使用]]></title>
    <url>%2F2020%2F05%2F26%2FThreadLocal%E5%8F%8A%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文主要讨论ThreadLocal，InheritableThreadLocal以及Transmittablethreadlocal的使用和这三者之间的一些异同。 ThreadLocalThreadLocal，翻译为线程局部变量，支持泛型的get和set方法，当我们的代码是在同个线程里面执行的时候，那么通过ThreadLocal变量取得的是值传递的同一个对象，以下代码做一个简单的示例 123456789101112131415161718public class ThreadLocalTest &#123; private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; ThreadLocalTest threadLocalTest = new ThreadLocalTest(); threadLocal.set(&quot;testThreadLocal&quot;); System.out.println(&quot;step1:&quot; + threadLocalTest.step1()); System.out.println(&quot;step2:&quot; + threadLocalTest.step2()); &#125; public String step1() &#123; return threadLocal.get(); &#125; public String step2() &#123; return threadLocal.get(); &#125;&#125; 执行后控制台输出 12step1:testThreadLocalstep2:testThreadLocal 可能你会觉得说这种场景下和我使用一个普通的static的静态变量（比如说Set）不是一样的效果吗？非也非也，我们使用一个多线程的例子来看看 1234567891011121314151617181920212223242526public class MultipleThreadLocalTest implements Runnable&#123; private static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; MultipleThreadLocalTest threadLocalTest = new MultipleThreadLocalTest(); threadLocal.set(&quot;testThreadLocal&quot;); System.out.println(Thread.currentThread().getName() + &quot; step1:&quot; + threadLocalTest.step1()); System.out.println(Thread.currentThread().getName() + &quot; step2:&quot; + threadLocalTest.step2()); Thread thread = new Thread(threadLocalTest); thread.start(); &#125; public String step1() &#123; return threadLocal.get(); &#125; public String step2() &#123; return threadLocal.get(); &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; run:&quot; + threadLocal.get()); &#125;&#125; 在上面这个例子里面，除了step1和step2之外，我们还创建了一个子线程，打印threadLocal的值，控制台输出结果为 123main step1:testThreadLocalmain step2:testThreadLocalThread-0 run:null 可以看到，在主线程当中是能够打印出set的值得，但是子线程是无法获得的。我们可以和单纯的静态变量做一个对比：修改ThreadLocal变量为Set变量，同时修改相关的代码 123main step1:[testThreadLocal]main step2:[testThreadLocal]Thread-0 run:[testThreadLocal] 可以看到这种场景下的static的变量是父子线程都能够读取到的，而这个其实会导致多线程同步的问题（父子线程同时对变量进行修改），可以通过加锁的方式来解决。 InheritableThreadLocal通过上面的ThreadLocal了解了使用的一些场景，那么当我们想要在创建子线程的时候能够将变量和子线程一起共享的时候，InheritableThreadLocal就应运而生了。 InheritableThreadLocal直接翻译可以理解为可继承的线程局部变量，接下来我们简单修改下ThreadLocal里面的示例代码 1234567891011121314public class MultipleThreadLocalTest implements Runnable&#123; private static InheritableThreadLocal&lt;String&gt; threadLocal = new InheritableThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; MultipleThreadLocalTest threadLocalTest = new MultipleThreadLocalTest(); threadLocal.set(&quot;testThreadLocal&quot;); Thread thread = new Thread(threadLocalTest); thread.start(); &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; run:&quot; + threadLocal.get()); &#125;&#125; 运行代码后，打印输出 1Thread-0 run:testThreadLocal 可以看到，子线程此时也已经拿到了父线程的线程变量，这就是可继承。 这种继承的过程是在初始化线程的时候完成的，其实可以简单理解为一个变量的复制，既然涉及到了变量的复制，那么就需要考虑下子线程对泛型变量的修改是否生效的问题，其实这个问题也相当简单，就和java的方法调用是值传递还是引用传递的问题的解答是一样的，上代码 1234567891011121314151617181920212223public class InheritableThreadLocalTest implements Runnable&#123; private static InheritableThreadLocal&lt;List&lt;String&gt;&gt; threadLocal = new InheritableThreadLocal&lt;&gt;(); public static void main(String[] args) throws InterruptedException &#123; InheritableThreadLocalTest threadLocalTest = new InheritableThreadLocalTest(); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); threadLocal.set(list); Thread thread = new Thread(threadLocalTest); thread.start(); Thread.sleep(1000); System.out.println(threadLocal.get().toString()); &#125; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; run:&quot; + threadLocal.get()); threadLocal.get().add(&quot;b&quot;); &#125;&#125; 这段代码我们做了什么事情呢，我们使用了InheritableThreadLocal，泛型为List，然后我们在子线程里执行了如下操作 1threadLocal.get().add(&quot;b&quot;); 在父线程进行sleep之后，打印InheritableThreadLocal，可以看到 12Thread-0 run:[a][a, b] 证实了这种修改是生效的，但是，如果我们在子线程里面执行如下代码 1threadLocal.set(new ArrayList&lt;&gt;()); 可以看到这个赋值对于父线程的线程变量是不起作用的，其实就和方法调用时的入参传递道理是一样的，这一点是需要格外注意的。 Transmittablethreadlocal既然上面有了可继承的变量，那么Transmittablethreadlocal又有什么作用呢？ 其实上面提到了很重要的一点，InheritableThreadLocal的线程变量的继承是在创建线程的时候传递的，但是大部分时候我们都是通过线程池的方式来执行多线程的操作，这么一来如果采用InheritableThreadLocal不就乱套了吗， 1234567891011121314151617181920212223public class MultiplePoolThreadLocalTest &#123; private static InheritableThreadLocal&lt;String&gt; threadLocal = new InheritableThreadLocal&lt;&gt;(); public static void main(String[] args) throws InterruptedException &#123; threadLocal.set(&quot;testThreadLocal&quot;); ExecutorService fixedThreadPool = Executors.newFixedThreadPool(1); fixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; run:&quot; + threadLocal.get()); &#125; &#125;); Thread.sleep(1000); threadLocal.set(&quot;testThreadLocal2&quot;); fixedThreadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; run:&quot; + threadLocal.get()); &#125; &#125;); &#125;&#125; 在这段代码里面，我们初始化了一个定长的线程池，size为1，然后先execute一次之后，更新InheritableThreadLocal的值，然后再execute，控制台输出为 12pool-1-thread-1 run:testThreadLocalpool-1-thread-1 run:testThreadLocal 我们可以看到，两次的打印的线程名是一样的，因为是线程池，所以重用了这个线程，而正因为是重用，所以并没有创建线程这个过程，所以第二次的打印的InheritableThreadLocal的值还是初始的值。 而Transmittablethreadlocal就是为了解决这个问题，核心思想是在执行的时候对线程局部变量进行继承而非创建线程的时候，我们对代码进行修改（需要先引入相关依赖） 1234567891011121314151617181920212223public class MultiplePoolThreadLocalTest &#123; private static TransmittableThreadLocal&lt;String&gt; threadLocal = new TransmittableThreadLocal&lt;&gt;(); public static void main(String[] args) throws InterruptedException &#123; threadLocal.set(&quot;testThreadLocal&quot;); ExecutorService fixedThreadPool = Executors.newFixedThreadPool(1); fixedThreadPool.execute(TtlRunnable.get(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; run:&quot; + threadLocal.get()); &#125; &#125;)); Thread.sleep(1000); threadLocal.set(&quot;testThreadLocal2&quot;); fixedThreadPool.execute(TtlRunnable.get(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; run:&quot; + threadLocal.get()); &#125; &#125;)); &#125;&#125; 修改的内容主要有 InheritableThreadLocal 修改为TransmittableThreadLocal 使用TtlRunnable.get()对Runnable做一层包装 执行后控制台输出 12pool-1-thread-1 run:testThreadLocalpool-1-thread-1 run:testThreadLocal2 两次的打印，线程名称是一样的，但是打印出来的变量值是不同的，符合我们的预期。 与Springboot中Async配合使用在Springboot开发web接口时，我们经常会使用Async注解来实现异步多线程的操作，那么怎么样在这种场景下面和ThreadLocal配合使用呢？ 和上一小节我们需要使用TtlRunnable对Runnable进行包装一样，在使用线程池时我们同样需要修改下线程池配置 12345678910@Configurationpublic class AsyncThreadPoolConfiguration implements AsyncConfigurer &#123; @Override public Executor getAsyncExecutor() &#123; ExecutorService fixedThreadPool = Executors.newFixedThreadPool(2); // 重点：使用 TTL 提供的 TtlExecutors return TtlExecutors.getTtlExecutor(fixedThreadPool); &#125;&#125; 我们使用一个简单的接口验证下 123456789101112131415161718192021//TestController.java public static TransmittableThreadLocal threadLocal = new TransmittableThreadLocal(); @Autowired TestService testService; @RequestMapping(value = &quot;/async&quot;, method = RequestMethod.GET) public void testAsync(@PathParam(&quot;value&quot;) String value) throws InterruptedException &#123; System.out.println(&quot;value is &quot; + value); threadLocal.set(&quot;set in main &quot; + value); testService.test(); &#125; //TestService.java@Servicepublic class TestService &#123; @Async public void test() throws InterruptedException &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + TestController.threadLocal.get()); Thread.sleep(3000); &#125;&#125; 我们分别调用如下三次接口 123http://localhost:8080/async?value=1http://localhost:8080/async?value=2http://localhost:8080/async?value=3 可以看到打印内容为 123456value is 1pool-1-thread-1:set in main 1value is 2pool-1-thread-2:set in main 2value is 3pool-1-thread-1:set in main 3 确认这个情况下是正常set和get的，但是如果我们将线程池配置里面最关键的一行去掉呢，如下 12345678910@Configurationpublic class AsyncThreadPoolConfiguration implements AsyncConfigurer &#123; @Override public Executor getAsyncExecutor() &#123; ExecutorService fixedThreadPool = Executors.newFixedThreadPool(2); return fixedThreadPool; // 重点：使用 TTL 提供的 TtlExecutors //return TtlExecutors.getTtlExecutor(fixedThreadPool); &#125;&#125; 同样的还是调用三次接口，可以看到控制台打印内容为 123456value is 1pool-1-thread-1:set in main 1value is 2pool-1-thread-2:set in main 2value is 3pool-1-thread-1:set in main 1 可以发现，第三次请求的时候，由于线程池中线程的复用，并且没有对线程池中的线程做委托处理（TtlExecutors.getTtlExecutor），所以导致我们对ThreadLocal的赋值并没有生效。 参考 transmittable-thread-local-GitHub 通过transmittable-thread-local源码理解线程池线程本地变量传递的原理 Spring @Async异步调用（异步线程池） 如何在子线程和线程池中使用 ThreadLocal 传输上下文 TransmittableThreadLocal 解决 线程池线程复用 无法复制 InheritableThreadLocal 的问题.]]></content>
  </entry>
  <entry>
    <title><![CDATA[java线上问题排查]]></title>
    <url>%2F2020%2F05%2F26%2Fjava%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[java线上问题排查系统线上运行时，跑着跑着总是可能会发生一些意料之外的事情，这里我们大致可以分为两类为问题，一类是CPU的问题，一类是内存的问题；而其中内存又可以分为内存泄漏与频繁GC，以下就从这几个方面展开探讨。 CPU占用率高 前置：此处我们模拟一个会导致CPU飚高的场景：死循环 123456789@RestControllerpublic class TestController &#123; @RequestMapping(value = &quot;/cpu&quot;, method = RequestMethod.GET) public void test() &#123; while (true) &#123; &#125; &#125;&#125; 请求接口几次之外，查看本机的CPU占用率，执行top命令可以看到 12 PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND15165 wilbert 20 0 3481140 236596 13196 S 197.7 6.3 0:56.27 java 分析从上面我们可以看到进程的ID为15165，我们都知道java是单进程多线程，接下来我们看下PID为1312进程里面线程的CPU占用情况，执行命令top -Hp 15165 1234 PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 15283 wilbert 20 0 3481140 236596 13196 R 86.7 6.3 1:04.36 http-nio-8080-e 15284 wilbert 20 0 3481140 236596 13196 R 60.0 6.3 0:38.89 http-nio-8080-e 15287 wilbert 20 0 3481140 236596 13196 R 53.3 6.3 0:17.27 http-nio-8080-e 这个时候我们可以看下具体线程的CPU占用率，我们此处以查看PID为15283的线程为例，将其转为十六进制，执行命令printf %x 15283，得到十六进制为 13bb3 接下来通过jstack命令查看指定线程的堆栈信息jstack 15165 |grep -A 200 3bb3，可以看到如下内容 123&quot;http-nio-8080-exec-1&quot; #115 daemon prio=5 os_prio=0 tid=0x00007fbb5877f800 nid=0x3bb3 runnable [0x00007fbb0f9fa000] java.lang.Thread.State: RUNNABLE at com.wilbert.java.check.demo.controller.TestController.test(TestController.java:15) 看到了内存的堆栈信息之后，我们就可以查看具体的代码TestController.java:15，然后再根据代码就可以分析出具体的原因了。 内存问题OOM 工具 jmap导出vm信息，visualvm分析vm信息 前置：我们先准备一个导致OOM的场景（通过不断在堆上创建对象实现） 1234567891011private static class TestOOM &#123; private String string = &quot;&quot;; &#125; public static void main(String[] args) &#123; List&lt;TestOOM&gt; list = new ArrayList&lt;TestOOM&gt;(); //在堆中无限创建对象 while (true) &#123; list.add(new TestOOM()); &#125; &#125; 修改程序启动参数 123-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/Users/wilbert/Documents/project/java-check/my.dump Xms 和Xmx分别代表初始和最大分配内存，后面两个代表在发生OOM的时候将内存信息dump到指定到文件上。main方法执行后，如愿以偿的看到 1234567891011java.lang.OutOfMemoryError: Java heap spaceDumping heap to /Users/wilbert/Documents/project/java-check/my.dump ...Heap dump file created [34385753 bytes in 0.189 secs]Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) at java.util.Arrays.copyOf(Arrays.java:3181) at java.util.ArrayList.grow(ArrayList.java:265) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231) at java.util.ArrayList.add(ArrayList.java:462) at com.wilbert.java.check.demo.controller.TestController.main(TestController.java:41) 接下来我们借助visualvm对my.dump文件进行分析 通过这个，我们可以很简单的看出是哪些对象占用了最多的堆内存，为我们的问题排查提供方向。 一些内存泄漏导致无法GC的变量我们也可以通过对dump文件进行分析查看到。 频繁GC 工具：jstack 频繁GC与前面CPU占用率高和OOM这几者其实是互为因果关系的 查看GC情况执行命令jstat -gc 15165 1000，其中15165是进程号，1000是每隔1s打印一次 当出现频繁的FGC的时候就需要关注了，可能是你的代码中存在内存泄漏，可以结合上面OOM问题中的jmap和visualvm对内存进行分析。]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql之索引的具体实现todo]]></title>
    <url>%2F2020%2F05%2F18%2Fmysql%E4%B9%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[mysql之索引]]></title>
    <url>%2F2020%2F05%2F13%2Fmysql%E4%B9%8B%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[mysql之索引全文keyword： 123索引 聚簇索引 非聚簇索引 覆盖索引 回表B+树 哈希索引 最左匹配 联合索引 innodb myisam 什么是索引 数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。 —from维基百科 索引用来快速定位数据，避免每次访问时对数据库的每一行进行检索操作 提炼一下，索引就是一种数据结构，通过这种数据结构来实现对数据库表中数据的高效操作，其实也是一种典型的空间换时间的思想的提现。 索引及数据的组织方式根据索引和具体数据的组织存储方式，我们可以分为聚簇索引（Clustered）和非聚簇（Non-clustered）索引 先引用网上的一张图 这张图描述的是表（拥有主键id和name字段）在id和name上的索引的两种方式。 左边图片中，主键索引就是聚簇索引，可以看到此处的叶子节点和数据行存放在一起了，因为无法将数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引；接下来看辅助键索引（name字段上的索引），此处的叶子节点存放的就是该字段对应的键值以及主键id，所以当我们通过这个索引进行数据查询时，我们还需要通过主键id的聚簇索引进行再一次的查找才能定位到具体的行记录，这个过程就是回表，下面会提到怎么样通过索引覆盖的方式来避免回表，从而提高查询的效率。 右边图片中，主键索引和辅助键索引并没有差异，两者的叶子节点都不存放数据行，而是通过指针的方式指向了数据存放的位置。所以，可以看出，二者最核心的区别就是叶子节点是否包含完整的数据行。 MyISAM 和 InnoDB 此两者是mysql的两种存储引擎 V5.1之前默认存储引擎是MyISAM；在此之后默认存储引擎是InnoDB InnoDB支持事务，MyISAM不支持事务 基于上面所述的聚簇索引，所以推荐InnoDB引擎使用自增主键，在没有显式设置主键时，会默认生成一个不可见的 索引覆盖上面提到，在聚簇索引里面，如果使用辅助键索引进行数据查询时，需要进行回表操作，增加了一次查询，我们可以通过在想要查询的语句上建立联合索引来避免回表操作（待查询的语句作为索引的一部分已经保存在叶子节点上，所以不需要回表来获得想要的字段信息）。 索引的实现首先明确一点，我们在索引及数据的组织方式中所采用的数状结构其实就是概念上的索引的一种实现方式，常见的用来实现索引的数据结构有平衡树，B+数和哈希. 此处我们简单粗暴地区分为树和哈希，顾名思义，二者分别是使用树和哈希表来使用索引，而我们知道这两种数据结构的特点，哈希索引的检索可以一次定位，而树的索引则需要从根节点都叶子节点才能够检索到，基于此，两者索引也有不同的优缺点及不同的应用场景，而在大部分场景下，哈希索引都是比较局限的，所以我们一般采用的是B+树索引的实现。 索引的失效及其原因基于上面提到的索引实现，在某些场景下索引会失效，这部分内容以及索引的具体实现会另外进行剖析。 参考 说一下聚簇索引 &amp; 非聚簇索引 知乎-Mysql 中 MyISAM 和 InnoDB 的区别有哪些？ Mysql聚簇索引和非聚簇索引原理（数据库） Mysql中Innodb表的默认主键_rowid MySQL 的覆盖索引与回表 维基百科-Database index]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo-blog配置cdn]]></title>
    <url>%2F2020%2F05%2F13%2Fhexo-blog%E9%85%8D%E7%BD%AEcdn%2F</url>
    <content type="text"><![CDATA[hexo-blog配置cdn前置条件 hexo，next主题 通过GitHub page进行部署 问题 访问速度慢 解决方案使用gitee替换github 注册gitee账号，地址 gitee 新建仓库 gitee中仓库里开启GitHub page服务 修改hexo的deploy地址 修改hexo项目配置文件_config.yml文件中deploy部分 注意 开启Gitee Pages时，如果项目名称和用户名称不一致的话，那么你的访问地址会有一个后缀，这个后缀是你在创建仓库时所设置时的路径地址（此处我的配置是hexo），这种情况下还需要修改hexo项目配置文件_config.yml中的root部分配置，否则部署之后会由于路径问题加载不到css和js文件，样式会出现问题 使用Gitee Pages时，访问速度的确提升了不少，但是最终还是没有采用这种方式，主要原因是我需要用自己的域名，而Gitee Pages除了自定义域名收费之外，域名还需要是已经备案的，此外，Gitee Pages进行发布之后，还需要每次手动点击下更新，属实麻烦，这几点就导致了我放弃了这种方式了，只能采用第二种方式，尽可能的优化访问速度了。 使用cdn加速主要分为两个部分来看 加速常见的通用前端文件主要是一些比较常见的前端文件，像是jquery这种，next主题里面提供了十分便捷的修改方式，打开主题配置文件_config.yml，搜索关键词Script Vendors，接下来就很简单了，按照文件名称和版本号一个个去找对应的cdn地址，找不到对应的cdn地址的话就置空就行了，我这边使用使用的几个cdn是 https://www.bootcdn.cn/ https://www.jsdelivr.com/ 修改后的内容为（供参考） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: //cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: //cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js fancybox_css: //cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: //cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: //cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: //cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: //cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: //cdn.jsdelivr.net/ua-parser.js/0.7.10/ua-parser.min.js # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: //maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: //cdn.bootcdn.net/ajax/libs/pace/1.0.2/pace.js pace_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: # three three: //cdn.bootcdn.net/ajax/libs/three.js/10/three.js # three_waves # https://github.com/jjandxa/three_waves three_waves: # three_waves # https://github.com/jjandxa/canvas_lines canvas_lines: # three_waves # https://github.com/jjandxa/canvas_sphere canvas_sphere: # Internal version: 1.0.0 # https://github.com/zproo/canvas-ribbon canvas_ribbon: # Internal version: 3.3.0 # https://github.com/ethantw/Han han: # needMoreShare2 # https://github.com/revir/need-more-share2 needMoreShare2: 加速项目自己的前端文件除了上面常用的一些前端资源的cdn之外，我们还可以通过jsdelivr来对我们项目自己的前端文件进行加速。 从此处可以看到，jsdelivr将GitHub上的文件都cdn起来了（当然前提是你的仓库是公开的），那么我们就可以使用这个cdn来加载我们项目里的前端文件了，同样是修改next主题配置文件_config,yml，搜索Assets，下面是修改前后的对比（注释掉的内容是修改前） 1234567# Assets# css: css# js: js# images: imagescss: //cdn.jsdelivr.net/gh/user/repo@master/cssjs: //cdn.jsdelivr.net/gh/user/repo@master/jsimages: //cdn.jsdelivr.net/gh/user/repo@master/images 注意将user和repo修改为自己对应的用户名和仓库名称 可以先自己尝试着看能不能访问到对应的js文件来进行验证 验证 打开网站，查看js等文件的加载地址，可以看到已经是通过cdn进行访问了 查看页面，访问起来速度的确加快了不少，但是由于index.html依然是需要从GitHub服务器加载，所以访问速度也还是不甚理想。 参考 Next主题 设置 「JavaScript 第三方库」 使用 jsDelivr 免费加速 GitHub Pages 博客的静态资源 尝试折腾了下用 Hexo-Next-Theme 搭建的博客 知乎-如何为备不了案的域名CDN加速？ 使用Gitee+Hexo搭建个人博客 当要部署的项目与自己的个性地址不一致时，部署完成后存在一些资源访问404]]></content>
  </entry>
  <entry>
    <title><![CDATA[免费ngrok使用]]></title>
    <url>%2F2020%2F05%2F12%2F%E5%85%8D%E8%B4%B9ngrok%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[免费ngrok使用 云服务器这种东西，总是拥有的时候总感觉没有什么用，等到到期了之后想着跑点什么，才追悔莫及。四月份的时候阿里云到期了，想说再续费，但是转念又想又好像没有那么大的需求，刚好目光看到了陈旧的笔记本，这不就能够利用起来了吗。 于是安装了centos，一顿操作，终于又有了一台7*24的服务器了 只是，没有公网ip要怎么办呢，一般了解之下，发现了ngrok这么个东西，其实就是一个内网穿透的工具而已 那么问题又来了，如果要自己搭建ngrok的话，那么又需要有一台拥有公网ip的服务器，又回到了原点 正当一筹莫展时，发现了有免费的ngrok服务器可用，maybe安全性可能有问题吧，但是也只是随便用用，问题不大。 Sunny-Ngrok 小米球ngrok 其中Sunny-Ngrok免费的服务器只有美国服务器，国内连接的话网速还是比较差的 这两者使用都比较简单，按照说明，修改相关的配置启动就可以了，需要注意的是小米球如果要后台运行的话，启动命令需要修改-log参数为stdout 1nohup ./ngrok -log=stdout -config ngrok.conf start tcptun &amp;]]></content>
  </entry>
  <entry>
    <title><![CDATA[黑苹果及mbp外接显示器开启HiDPi]]></title>
    <url>%2F2020%2F05%2F11%2F%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%8F%8Ambp%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8%E5%BC%80%E5%90%AFHiDPi%2F</url>
    <content type="text"><![CDATA[黑苹果及mbp外接显示器开启HiDPi 设备 黑苹果，系统版本 10.15 MacBook Pro， 系统版本 10.15 外接显示器，AOC 24寸 1920*1080 疑问在这几个月的使用下来，有几个疑问 比起win10，在黑苹果下/mbp外接显示器下字体发虚，模糊 mbp外接显示器时感觉性能更好 在网上找了一些相关的资料后，了解到了MacOS的HiDPi的渲染方式 HiDPI是什么？以及黑苹果如何开启HiDPI 有关retina和HiDPI那点事 简而言之，就是macOS是将四个像素点合并成一个像素点去进行渲染的，默认情况下1080p的显示器时不会采用这种渲染方式的，那么我们就需要开启HiDPi，可以知道，这种情况下其实显示器内的可视内容会减少；而采用这种渲染模式的话，其实会更依赖显卡的性能，这也是疑问二在外接显示器时感觉性能更好的原因 开启HiDPi参考教程 一键开启macOS HiDPI 黑苹果在选择分辨率时选择手动输入，输入 11920x1080 1680x945 1536x864 1440x810 1280x720 重启后即可在系统设置里面进行缩放设置，注意此时要选择 1536x864，才能达到比较好的显示效果 MBP比起黑苹果，要增加一步 关闭SIP，参考 https://tnext.org/4521.html中关闭SIP部分，然后还是采用和黑苹果相同的命令，区别在于多了一步显示器的选择，注意要选择外接显示器，全程连接外接显示器 同样的，重启后在系统设置-显示器中，选择外接显示器后，可以进行缩放设置，同样的选择 1536x864]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用nacos配置中心]]></title>
    <url>%2F2020%2F04%2F29%2F%E4%BD%BF%E7%94%A8nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[使用nacos配置中心前言：此部分的内容基于 feignClient使用及切换eureka为nacos注册中心，代码地址见 https://github.com/weizhaowu-se/spring-eureka 分支： master-nacos 添加代码依赖 123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba.boot/nacos-config-spring-boot-starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;nacos-config-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.1.6&lt;/version&gt;&lt;/dependency&gt; 在MainApplication上添加注解 @NacosPropertySource(dataId = &quot;example&quot;, autoRefreshed = true)，注意此处的dataId对应的值，这个是我们在nacos配置平台上发布配置的对应环境 新增测试Controller 123456789101112@RestControllerpublic class ConfigGetController &#123; @NacosValue(value = &quot;$&#123;testConfig:1234&#125;&quot;, autoRefreshed = true) private String testConfig; @RequestMapping(value = &quot;/get&quot;, method = RequestMethod.GET) @ResponseBody public String get() &#123; return testConfig; &#125;&#125; @NacosValue(value = “${testConfig:1234}”, autoRefreshed = true)： 1234表示默认值，autoRefreshed表示默认刷新 测试访问地址 http://localhost:8091/get，得到返回 1234(由于我们此时还未配置，所以返回默认值) 在nacos配置管理上新增配置项 再次访问http://localhost:8091/get，配置生效]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elk部署-helloWorld]]></title>
    <url>%2F2020%2F04%2F29%2Felk%E9%83%A8%E7%BD%B2-helloWorld%2F</url>
    <content type="text"><![CDATA[elk部署-helloWorldelasticsearch 下载地址 https://www.elastic.co/cn/start 解压文件 elasticsearch-6.2.2 启动，进入bin文件夹，执行 12./elasticsearch./elasticsearch -d #后台模式运行 访问页面 http://localhost:9200/，启动成功 123456789101112131415&#123;name: &quot;B7lu623&quot;,cluster_name: &quot;elasticsearch&quot;,cluster_uuid: &quot;i4kmAxjsRr-V9v5CDfYn1A&quot;,version: &#123;number: &quot;6.2.2&quot;,build_hash: &quot;10b1edd&quot;,build_date: &quot;2018-02-16T19:01:30.685723Z&quot;,build_snapshot: false,lucene_version: &quot;7.2.1&quot;,minimum_wire_compatibility_version: &quot;5.6.0&quot;,minimum_index_compatibility_version: &quot;5.0.0&quot;&#125;,tagline: &quot;You Know, for Search&quot;&#125; kibana 下载地址 https://www.elastic.co/cn/start，需要注意的是版本要需要和elasticsearch对应，否则无法连接 解压文件 kibana-6.2.2-darwin-x86_64 启动，进入bin文件夹，执行 1./kibana 访问页面 http://localhost:5601/ 默认情况下kibana连接的elasticsearch地址是 http://localhost:9200，如果需要修改的话，可以修改目录 /config/kibana.yml文件中的配置 logstash 下载地址 https://artifacts.elastic.co/downloads/logstash/logstash-7.6.2.zip 解压 一个最简单的测试， 12进入bin目录下，执行 ./logstash -e &apos;input &#123; stdin &#123;&#125; &#125; output &#123; stdout &#123;&#125; &#125;&apos;这个命令的意思是将输入的内容输出到标准输出中，效果如下图 将日志输出到es当中 一般来讲我们是将程序产生的日志文件输出到elasticsearch中，此处我们就直接将elasticsearch的日志输出到es当中，es的日志文件位置在 logs/elasticsearch.log 新建elasticsearch.conf 的logstash配置文件，放在目录/log-conf/下（手动新建目录） 12345678910111213141516input &#123; file &#123; path =&gt;&quot;/Applications/sh/elasticsearch-6.2.2/logs/elasticsearch.log&quot; type =&gt;&quot;elasticsearch&quot; start_position =&gt;&quot;beginning&quot; &#125;&#125;output &#123; elasticsearch &#123; hosts=&gt;[&quot;127.0.0.1:9200&quot;] index =&gt;&quot;es-message-%&#123;+YYYY.MM.dd&#125;&quot;&#125; stdout &#123; codec =&gt; rubydebug &#125;&#125; 启动logstash，执行命令 ./bin/logstash -f log-conf/elasticsearch.conf 至此，elk已经部署完成，接下来我们到kibana上进行查看 综合查看 查看索引 查看索引数据]]></content>
      <tags>
        <tag>elasticsearch</tag>
        <tag>kibana</tag>
        <tag>logstash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[feignClient使用及切换eureka为nacos注册中心]]></title>
    <url>%2F2020%2F04%2F28%2FfeiginClient%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%88%87%E6%8D%A2eureka%E4%B8%BAnacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[此文接着上篇内容 spring-eureka-hello-world，代码仓库地址： https://github.com/weizhaowu-se/spring-eureka 分支： master-nacos feignClient使用上次通过客户端调用服务方时，采用的是restTemplate的方式，代码如下 1234567 @AutowiredRestTemplate restTemplate;@RequestMapping(value = &quot;/helloConsumer&quot;, method = GET)public String helloConsumer() &#123; return restTemplate.getForEntity(&quot;http://SERVICE-HELLO/hello&quot;, String.class).getBody();&#125; 始终是有点丑陋，我们现在通过 FeignClient 的方式来进行RPC调用。 引入依赖包 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在MainApplication配置注解 @EnableFeignClients 新建接口如下 12345@FeignClient(value = &quot;SERVICE-HELLO&quot;)public interface HelloService &#123; @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET) String hello();&#125; 可以看到，类上面的FeignClient 对应的value为调用的服务名，而方法上的value则是对应具体的地址 在Controller中新增通过FeignClient调用的接口方法 1234567@Autowired HelloService helloService;@RequestMapping(value = &quot;/helloConsumerFeignClient&quot;, method = GET) public String helloConsumerFeignClient() &#123; return helloService.hello(); &#125; 重启应用，访问接口 http://localhost:8091/helloConsumerFeignClient,访问成功 切换为nacos注册中心上面我们使用的是eureka作为服务注册中心，现在我们修改为通过nacos实现服务注册与服务发现 启动本地nacos，参考地址 https://nacos.io/zh-cn/docs/quick-start.html,启动命令为 1sh startup.sh -m standalone 访问 http://localhost:8848/nacos,账号密码 nacos/nacos 修改服务提供方 添加nacos依赖，注释eureka依赖 123456789101112&lt;!-- https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-discovery --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--去除eureka依赖--&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;--&gt; 增加nacos服务器配置地址，去除eureka配置地址 123#eureka.client.service-url.defaultZone=http://localhost:8080/eurekaspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 重启应用，访问 http://localhost:8848/nacos，可以看到对应的服务 添加nacos依赖，注释eureka依赖 123456789101112&lt;!-- https://mvnrepository.com/artifact/com.alibaba.cloud/spring-cloud-starter-alibaba-nacos-discovery --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt; &lt;version&gt;1.5.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; &lt;!--&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;--&gt; 增加nacos服务器配置地址，去除eureka配置地址 123#eureka.client.service-url.defaultZone=http://localhost:8080/eurekaspring.cloud.nacos.discovery.server-addr=127.0.0.1:8848 重启应用，访问接口 http://localhost:8091/helloConsumerFeignClient 或者 http://localhost:8091/helloConsumer 至此，我们已经成功将eureka切换为nacos 参考 nacos快速开始 nacos-spring-cloud]]></content>
      <tags>
        <tag>springbo</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker私有仓库及k8s部署本地镜像]]></title>
    <url>%2F2020%2F04%2F19%2Fdocker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E5%8F%8Ak8s%E9%83%A8%E7%BD%B2%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[docker私有仓库及k8s部署本地镜像 执行命令启动私有仓库 1docker run -p 5000:5000 registry:2.0 执行命令后，会从DockerHub上拉取registry镜像并在本地启动Registry服务，并监听5000端口。 将本地镜像推送到本地仓库，此处以本地仓库的镜像springio/docker-domer:latest为例 12docker tag springio/docker-domer:latest localhost:5000/springio/docker-domer:latestdocker push localhost:5000/springio/docker-domer:latest K8s部署 yaml文件如下 123456789101112apiVersion: v1kind: Podmetadata: name: springboot-demo # 指定 label，便于检索 labels: app: springboot-demospec: containers: - name: springboot-demo # 指定镜像 image: localhost:5000/springio/docker-domer 启动完成后进入容器查看 证明已经启动成功 参考 docker创建私有仓库]]></content>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sprintboot&docker&HelloWorld]]></title>
    <url>%2F2020%2F04%2F19%2Fsprintboot-docker-HelloWorld%2F</url>
    <content type="text"><![CDATA[sprintboot&amp;docker&amp;HelloWorld初始化springboot项目 初始化springboot项目 新建HelloController 1234567@RestControllerpublic class HelloController &#123; @RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET) public String hello() &#123; return &quot;hello docker demo&quot;; &#125;&#125; docker相关依赖及文件配置新增依赖pom.xml里面添加如下 123456789101112131415161718192021222324&lt;properties&gt; &lt;docker.image.prefix&gt;springio&lt;/docker.image.prefix&gt;&lt;/properties&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;configuration&gt; &lt;imageName&gt;$&#123;docker.image.prefix&#125;/$&#123;project.artifactId&#125;&lt;/imageName&gt; &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath&gt;/&lt;/targetPath&gt; &lt;directory&gt;$&#123;project.build.directory&#125;&lt;/directory&gt; &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;/include&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; Dockerfile新建文件 src/main/docker/Dockerfile 1234FROM openjdk:8-jdk-alpineVOLUME /tmpADD docker-domer-0.0.1-SNAPSHOT.jar app.jarENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 打包镜像1mvn package docker:build 命令执行完成后，查看本地docker镜像列表 1docker images 可以看到 12REPOSITORY TAG IMAGE ID CREATED SIZEspringio/docker-domer latest 37c1337c6595 3 minutes ago 122MB 执行命令启动镜像 1docker run -i -t -p 8080:8080 springio/docker-domer:latest 访问HelloController测试接口 至此，已经完成了springboot镜像的打包同启动 代码地址：springboot-docker-demo]]></content>
      <tags>
        <tag>docker</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac下安装k8s&docker及HelloWorld]]></title>
    <url>%2F2020%2F04%2F18%2Fmac%E4%B8%8B%E5%AE%89%E8%A3%85k8s-docker%E5%8F%8AHelloWorld%2F</url>
    <content type="text"><![CDATA[mac下安装k8s&amp;docker及HelloWorld安装环境：macOS 安装docker下载地址：https://hub.docker.com/editions/community/docker-ce-desktop-mac 无脑点击下一步即可 启用k8s打开docker—preference—kurbernets，勾上Enable Kurbernets，注意，勾选上之后需要下载文件，这个过程比较耗时，需要耐心等待 安装k8s Dashboard及生成token登录 执行如下命令安装Dashboard 1234567kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta4/aio/deploy/recommended.yaml####启用代理kubectl proxy####访问地址http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#/login 访问dashboard地址，访问页面如下 生成token 123kubectl create serviceaccount dashboard-admin -n kube-systemkubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-adminkubectl describe secret -n kube-system dashboard-admin-token 使用token进行登录，登录后页面 使用k8s部署第一个应用-nginx 点开右上角的 ‘+’ 按钮 create from input里填入 123456789101112131415apiVersion: v1kind: Podmetadata: name: nginx # 指定 label，便于检索 labels: app: nginxspec: containers: - name: nginx # 指定镜像 image: nginx:alpine # 指定暴露端口 ports: - containerPort: 80 部署完成后 可以通过dashboard或者kubectl命令进入容器内部 1kubectl exec -it nginx sh 或者 综上我们已经成功通过k8s部署了第一个应用。 下面我们会通过另外两篇文章来说明如何将springboot的jar包打包成docker镜像，同时推送到镜像仓库中，并且通过k8s从镜像仓库拉取并且部署。]]></content>
      <tags>
        <tag>docker</tag>
        <tag>k8s</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-eureka-hello-world]]></title>
    <url>%2F2020%2F04%2F09%2Fspring-eureka-hello-world%2F</url>
    <content type="text"><![CDATA[spring-eureka-hello-world 核心概念 1spring-eureka：注册中心，实现服务注册和发现 Hello world代码地址 spring-eureka 注册中心server 初始化springboot（此处略去） 配置相关依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在Application启动类上增加注解 EnableEurekaServer 123456789@SpringBootApplication@EnableEurekaServerpublic class SpringEurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringEurekaServerApplication.class, args); &#125;&#125; application.properties增加如下配置项 12345server.port=8080eureka.instance.hostname=localhosteureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.service-url.defaultZone=http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka 各配置项的含义具体可以参见 https://blog.csdn.net/u010109732/article/details/79769488 启动程序后，访问页面 http://127.0.0.1:8080/,可以看到如下页面 服务提供者client 初始化springboot（此处略去） 配置相关依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在Application启动类上增加注解EnableDiscoveryClient 123456789@SpringBootApplication@EnableDiscoveryClientpublic class SpringEurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringEurekaClientApplication.class, args); &#125;&#125; 新增测试接口类 1234567@RestControllerpublic class HelloController &#123; @RequestMapping(value = &quot;/hello&quot;, method = RequestMethod.GET) public String hello() &#123; return &quot;hello springeurekaclient&quot;; &#125;&#125; 修改application.properties配置文件 12345server.port=8090spring.application.name=SERVICE-HELLOeureka.client.service-url.defaultZone=http://localhost:8080/eureka 配置项比较易懂，其中eureka.client.service-url.defaultZone为上一步的注册中心的地址，对应注册中心配置项中的url.defaultZone 启动程序后，先访问自身接口http://127.0.0.1:8090/hello 访问注册中心server http://127.0.0.1:8080/ 服务消费者consumer 初始化springboot（此处略去） 配置相关依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;version&gt;1.4.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 在Application启动类上增加注解EnableDiscoveryClient &amp; 添加Bean注册 123456789101112131415@SpringBootApplication@EnableDiscoveryClientpublic class SpringEurekaConsumerApplication &#123; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; SpringApplication.run(SpringEurekaConsumerApplication.class, args); &#125;&#125; 修改application.properties配置文件 12345server.port=8091spring.application.name=consumer-helloeureka.client.service-url.defaultZone=http://localhost:8080/eureka 新增测试接口类，通过注册中心调用上一步的client接口 12345678910@RestControllerpublic class HelloConsumerController &#123; @Autowired RestTemplate restTemplate; @RequestMapping(value = &quot;/helloConsumer&quot;, method = RequestMethod.GET) public String helloConsumer() &#123; return restTemplate.getForEntity(&quot;http://SERVICE-HELLO/hello&quot;, String.class).getBody(); &#125;&#125; 先访问注册中心页面 http://127.0.0.1:8080/ 访问页面接口 http://127.0.0.1:8091/helloConsumer 可以看到，我们已经调用到了上一步client提供的接口 参考 Spring Cloud入门教程(一)：服务治理(Eureka)]]></content>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud配置中心]]></title>
    <url>%2F2020%2F04%2F06%2FSpringCloud%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%2F</url>
    <content type="text"><![CDATA[SpringCloud配置中心服务端spring-config-server完整代码地址 初始化springboot项目 新增配置中心依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; 本地配置的方式 修改application.properties 1234spring.application.name=service-configspring.profiles.active=native#指定配置文件位置为classpath目录下的config目录spring.cloud.config.server.native.searchLocations=classpath:/config 在resource目录下新建config及新建配置文件 1234resource config service-dev.properties service-prod.properties 此处的 service 为对应的服务名称，可自定义， -后面的为指定的环境，可自定义 service-dev.properties 文本内容 12env.name=dev env.password=dev123456 service-prod.properties 文本内容 12env.name=product env.password=product123456 git远程仓库配置方式 —todo 经过了4/5的步骤之后，启动config-server项目，可以从浏览器访问可以查看到对应的配置信息，如下 访问 http://localhost:8080/service/dev获得service-dev配置 访问 http://localhost:8080/service/prod 获得 service-prod配置 客户端spring-config-client完整代码地址 初始化springboot项目 新增config依赖配置 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/dependency&gt; resource 目录下新增文件 bootstrap.properties 123456# 对应服务端的某个配置服务spring.application.name=service# 配置中心地址spring.cloud.config.uri=http://127.0.0.1:8080# 启用的配置中心的某个配置文件spring.cloud.config.profile=prod 新增 HelloController进行验证 12345678910@RestControllerpublic class HelloController &#123; @Value(&quot;$&#123;env.password&#125;&quot;) private String password; @RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET) public String testProfiles() &#123; return password; &#125;&#125; 访问上一步新增的接口 配置刷新 todo注册中心eurka todohttps://www.jianshu.com/p/d32ae141f680 TIPS 注意SpringBoot和SpringCloud的版本对应关系，否则可能会启动失败]]></content>
  </entry>
  <entry>
    <title><![CDATA[台式机安装黑苹果]]></title>
    <url>%2F2020%2F03%2F22%2F%E5%8F%B0%E5%BC%8F%E6%9C%BA%E5%AE%89%E8%A3%85%E9%BB%91%E8%8B%B9%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[台式机配置如下 模块 型号 CPU i5-9400f 主板 微星（MSI）B360M MORTAR迫击炮 显卡 铭瑄RX580 2048SP 刻盘 镜像文件： https://mirrors.dtops.cc/iso/MacOS/daliansky_macos/ 下载的是 macOS Catalina 10.15.3(19D76) Installer for Clover 5103 and WEPE.dmg 这个 下载etcher， 打开镜像，选择U盘，点击Flash即可。Windows10需要以管理员权限运行 刷显卡的vbios1显卡型号是AMD的RX580，由于黑苹果能够直接支持的型号为RX570，又因为580是570的马甲卡，所以可以通过刷570的bios来实现“欺骗” 具体教程参考 铭瑄RX580 2048SP刷RX570VBIOS实现黑苹果免驱 重启，u盘启动这个时候出现了第一个问题 1Error allocating 0x11c8d pages at 0x0000 alloc type 2 启动是报了类似的错误，这个时候上网查找了一下， 解決黑蘋果開機出現Error allocating 0x11c8d pages at 0x0000 alloc type 2 提到需要替换u盘的efi中的 OsxAptioFix2Drv-free2000.efi 文件，这个时候回过头去看了下 【黑果小兵】macOS Catalina 10.15.3 19D76 正式版 with Clover 5103原版镜像[双EFI版]，发现里面也有提到 1300系列主板请于UEFI目录中移除AptioMemoryFix-64.efi添加OsxAptioFix2Drv-free2000.efi该驱动位于/EFI/CLOVER/drivers/off目录下 所以果断按照此操作将u盘里的文件移除&amp;移动了一下（在Windows下通过diskgenius进行的操作） 再次重启参考教程 macOS安装教程兼小米Pro安装过程记录 磁盘工具 抹盘 Mac OS扩展(日志型) Macintosh HD 安装macOS 没什么好说的，按照页面一步步点，耐心等待 复制u盘的efi到硬盘上上一步的安装完成之后其实就可以进入系统了，但是是通过U盘的efi引导进入的，所以我们需要将u盘里的efi文件拷贝到当前的系统安装硬盘上，这样才能脱离u盘直接启动系统。 下面两个教程我都操作了一下，本来一直不行，莫名其妙就好了。。。 参考教程教你将U盘上的EFI复制到磁盘的EFI分区,脱离USB运行[macOS篇] 不借助任何工具将CLOVER引导添加进UEFI的正确姿势 关于网络直接使用了有线网卡。 关于蓝牙原来使用的usb蓝牙适配器也能直接连上AirPods。 隔空投送等这部分需要网卡和蓝牙模块都适配，也就不折腾了。 APPLE ID登录 直接进行登录时会提示设备绑定的appleid已达到上限，猜测是这个镜像有不少人使用了，而镜像里是绑定了一个序列号的，所以需要进行修改，在此使用的工具是 Clover Configurator，参考文章 为自己的黑苹果生成随机三码进行操作，其实就是随机生成序列码，配置到efi文件里 参考链接 黑果小兵的部落阁 解決黑蘋果開機出現Error allocating 0x11c8d pages at 0x0000 alloc type 2 铭瑄RX580 2048SP刷RX570VBIOS实现黑苹果免驱 为自己的黑苹果生成随机三码 教你将U盘上的EFI复制到磁盘的EFI分区,脱离USB运行[macOS篇] 不借助任何工具将CLOVER引导添加进UEFI的正确姿势]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot集成mybatis及pageHelper的使用]]></title>
    <url>%2F2020%2F03%2F02%2Fspringboot%E9%9B%86%E6%88%90mybatis%E5%8F%8ApageHelper%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[springboot集成mybatis及pageHelper的使用简单集成新增maven依赖12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; application.properties配置前置条件：本地安装数据库 1234spring.datasource.driverClassName = com.mysql.jdbc.Driverspring.datasource.url = jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username = rootspring.datasource.password = password mapper代码12345@Mapperpublic interface TestMapper &#123; @Select(&quot;select * from user&quot;) List&lt;Map&gt; testSelect();&#125; controller代码注：此处为了简单，直接在controller注入mapper进行方法调用，实际项目中不推荐这样做 1234567891011@Controllerpublic class HelloController &#123; @Autowired TestMapper testMapper; @RequestMapping(value=&quot;/testMybatisSelect&quot;,method = RequestMethod.GET) @ResponseBody public String testMybatisSelect(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; return JSON.toJSONString(testMapper.testSelect()); &#125;&#125; 访问接口url: http://localhost:5050/test/testMybatisSelect 查看结果 访问成功 PageHelper的使用简单的说，就是实现分页的功能 Mybatis-PageHelper 新增maven依赖123456789101112&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.5&lt;/version&gt; &lt;/dependency&gt; 新增PageResult类1234567891011121314151617181920212223242526272829public class PageResult&lt;T&gt; &#123; private Long totalCount; private List&lt;T&gt; content; public PageResult() &#123; &#125; public PageResult(Long totalCount, List&lt;T&gt; datas) &#123; this.totalCount = totalCount; this.content = datas; &#125; public Long getTotalCount() &#123; return totalCount; &#125; public void setTotalCount(Long totalCount) &#123; this.totalCount = totalCount; &#125; public List&lt;T&gt; getContent() &#123; return content; &#125; public void setContent(List&lt;T&gt; content) &#123; this.content = content; &#125;&#125; 修改查询方法12345678@RequestMapping(value=&quot;/testMybatisSelect&quot;,method = RequestMethod.GET) @ResponseBody public String testMybatisSelect(@Param(&quot;pageNum&quot;)Integer pageNum, @Param(&quot;pageSize&quot;)Integer pageSize) throws IOException &#123; PageHelper.startPage(pageNum, pageSize); Page&lt;Map&gt; page = testMapper.testSelect(); PageResult pageResult = new PageResult(page.getTotal(), new ArrayList(page)); return JSON.toJSONString(pageResult); &#125; 访问url http://localhost:5050/test/testMybatisSelect?pageNum=1&amp;pageSize=2 注意 pageNum是从1开始，当然你从0开始也是可以的，只是0和1是查询到的结果是一样的，个人理解可能只是做了一个容错？ 关于pageHelper的实现也是一个蛮有趣的话题，后面可以翻下源码看下具体实现]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot集成quartz]]></title>
    <url>%2F2020%2F03%2F01%2Fspringboot%E9%9B%86%E6%88%90quartz%2F</url>
    <content type="text"><![CDATA[springboot集成quartz]]></content>
  </entry>
  <entry>
    <title><![CDATA[jwt基本概念及其在springboot的使用]]></title>
    <url>%2F2020%2F03%2F01%2Fjwt%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%85%B6%E5%9C%A8springboot%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[jwt基本概念及其在springboot的使用jwt概念全称：json web token JSON Web Token 入门教程 我的理解 与传统的session认证方式最显著的区别在于，jwt将用户信息存放在客户端，每次请求服务时再将此部分信息传给服务器（一般是通过header参数传递的方式） jwt主要分为三个部分： header：标识签名的算法等属性 payload：标识该jwt token的有效时间，签发人等信息，辨识调用方 signature：对前两者的签名，避免被篡改 一个jwt的流程如下 springboot中的使用参考： Spring Boot Security 整合 JWT 实现 无状态的分布式API接口 GitHub-springboot-jwt 在spring security的基础上新增token的校验，关于spring security后续补充，此处说明下修改的地方，主要有如下几个地方： 登录接口新增返回 jwttoken 新增过滤器 JwtTokenFilter 对请求header参数的token进行校验 修改http session状态为无状态 SecurityConfig中修改： 1234567891011121314151617181920@Override protected void configure(HttpSecurity http) throws Exception &#123; http.csrf().disable() //因为使用JWT，所以不需要HttpSession .sessionManagement().sessionCreationPolicy( SessionCreationPolicy.STATELESS).and() .authorizeRequests() .antMatchers( HttpMethod.OPTIONS, &quot;/**&quot;).permitAll() .antMatchers(&quot;/auth/login&quot;).permitAll() .anyRequest().authenticated(); //使用自定义的jwt Token过滤器 验证请求的Token是否合法 http.addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter.class); http.headers().cacheControl(); &#125; @Bean public JwtTokenFilter authenticationTokenFilterBean() throws Exception &#123; return new JwtTokenFilter(); &#125; 我理解的使用场景 正因为jwt的无状态的特性，那么对于服务器的横向扩展是十分方便的，但是同时也带来了一个问题，token签发之后一直到有效期结束之前都是有效的，所以无法实现类似A地登录B地退出，修改密码后所有客户端退出的功能，除非通过黑名单list的方式进行维护，通过黑名单的方式，借助于外界统一的存储介质（比如数据库或者redis），那么似乎就与jwt的无状态的特性相悖 基于以上的理解，jwt更适用于一些应用间的接口鉴权，而非web应用前后端的登录校验 参考资料 JSON Web Token 入门教程 Spring Boot Security 整合 JWT 实现 无状态的分布式API接口 讲真，别再使用JWT了！]]></content>
  </entry>
  <entry>
    <title><![CDATA[mybatis-threshold参数问题]]></title>
    <url>%2F2020%2F02%2F13%2Fmybatis-threshold%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[mybatis-threshold参数问题问题在mapper里面使用的函数方式使用如下参数 1@Param(&quot;threshold&quot;) String threshold mapper.xml里面如下(threshold为该表的一个字段) 12345678&lt;select id=&quot;queryCountByImageMd5&quot; resultType=&quot;java.lang.Integer&quot;&gt; SELECT * FROM xxxx WHERR and threshold = #&#123;threshold&#125;&lt;/select&gt; 结果报错，提示类型转换失败 解决办法修改参数名称 threshold —&gt; testthreshold 1@Param(&quot;testthreshold&quot;) String threshold 相应修改xml相关参数]]></content>
  </entry>
  <entry>
    <title><![CDATA[elasticsearch集群部署]]></title>
    <url>%2F2020%2F02%2F06%2Felasticsearch%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MQ消息最终一致性解决方案]]></title>
    <url>%2F2020%2F02%2F06%2FMQ%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[mysql之groupby获得分组指定记录]]></title>
    <url>%2F2020%2F02%2F06%2Fmysql%E4%B9%8Bgroupby%E8%8E%B7%E5%BE%97%E5%88%86%E7%BB%84%E6%8C%87%E5%AE%9A%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[mysql之groupby获得分组指定记录场景及需求有如下示例表(表名test)： 字段编码 字段名 id id 学科 subject 成绩 score 如果只是想要获得每个学科的最高分的话，那么 1select subject, score from test group by subject 上述sql能够获得需要的结果 但是更多时候我们想要的不仅仅是这样，我们还想要同时取得学科最高分对应的id，那么我们可以这样写 1select id, subject, score from (select * from test order by score) group by subject 原理group by后获取的第一条记录是默认第一条，那么我们先将其排序之后再去获取的，那么就能够获得到我们想要的那一条记录了 注意事项如果mysql版本为5.7及以上，那么需要在排序时增加一个limit 1select id, subject, score from (select * from test order by score limit 10000) group by subject 但是如果记录大于指定的limit的话，那么就会出现问题，所以这种情况只适用于数据量能够掌控的表。 查了一下之后发现另外一种方法 另一种方法 mysql实现group by后取各分组的最新一条 看了之后发现，这种仅限于你想要取得的字段的限定条件是唯一的情况，并不能够满足我们此种场景下的需求（此场景下的限定条件是最大成绩的那一条，而非最大id的记录） 所以如果想规避limit的问题，那么就 1select subject, score from test group by subject 后再用指定的subject和score去查询出对应的记录吧 1select * from test where subject = #&#123;subject&#125; and score = #&#123;score&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用github page以及hexo搭建博客（自定义域名）]]></title>
    <url>%2F2019%2F10%2F13%2F%E4%BD%BF%E7%94%A8github-page%E4%BB%A5%E5%8F%8Ahexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本地安装hexo安装hexo 查看文档 hexo安装 初始化项目常用命令 123456hexo init &lt;folder&gt;cd &lt;folder&gt;npm installhexo new post &apos;博客标题&apos; ---新建博文hexo generate -dhexo server ---本地启动服务器,启动后访问http://localhost:4000/ 常用文件 12_config.yml ---配置文件source/_posts ---博客源文件(md文件) github新建仓库-github page 新建仓库,仓库名称为 {yourusername}.github.io hexo与github page配置关联 配置hexo配置文件 _config.yml 1234deploy: type: git repo: https://github.com/&#123;username&#125;/&#123;username&#125;.github.io.git ##填写仓库地址 branch: master 执行命令 1hexo g -d 访问网址 1https://&#123;yourusername&#125;.github.io 配置自定义域名 source目录下新增文件,文件名为 CNAME (无后缀),文本内容为自定义域名(无http和www等前缀) 配置dns中的c类解析,将自定义域名映射为 {yourusername}.github.io 121. 先添加一个CNAME，主机记录写@，后面记录值写上你的http://xxxx.github.io2. 再添加一个CNAME，主机记录写www，后面记录值也是http://xxxx.github.io 参考hexo安装 GitHub Pages 使用入门]]></content>
  </entry>
  <entry>
    <title><![CDATA[测试-1013]]></title>
    <url>%2F2019%2F10%2F13%2F%E6%B5%8B%E8%AF%95-1013%2F</url>
    <content type="text"><![CDATA[test]]></content>
  </entry>
  <entry>
    <title><![CDATA[centos系统下wordpress的安装]]></title>
    <url>%2F2019%2F06%2F16%2Fcentos%E7%B3%BB%E7%BB%9F%E4%B8%8Bwordpress%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装apache,php1yum install -y httpd php php-mysql php-gd php-xml 启动&amp;重启apache服务123service httpd start //启动systemctl restart httpd.service //此命令亦可重启服务service httpd restart 重启 相关目录12/etc/httpd/conf/httpd.conf 配置文件位置/var/www/html 前端文件默认根目录 升级php配置yum源:12rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 卸载旧版本的php1rpm -e `rpm -qa|grep php` 安装新版本php:1yum install -y php72w php72w-mysql php72w-gd php72w-ldap php72w-odbc php72w-pear php72w-xml php72w-xmlrpc php72w-mbstring php72w-snmp 查看httpd是否加载了PHP7模块1ll /etc/httpd/modules/|grep php 查看php版本1php -v 安装mysql123456789101112yum localinstall http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpmyum install mysql-community-serverservice mysqld start//查看mysql的root账号的密码grep &apos;temporary password&apos; /var/log/mysqld.log//登录mysqlmysql -uroot -p//修改密码ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos;; 启动&amp;重启命令1service mysqld start 创建wordpress数据库1234//登陆数据库mysql –uroot –p//创建数据库create database wordpress; 配置wordpress下载文件1234访问网址 https://rup.wordpress.org/download/进入目录 /var/www/html下载文件 wget unzip 解压下载的文件 配置1cp wp-config-sample.php wp-config.php 修改文件相关配置 数据库相关配置(库名,用户名,密码,连接地址) 设置语言包 define(&#39;WPLANG&#39;, &#39;zh_CN&#39;); 设置ftp连接解决方式 define(&#39;FS_METHOD&#39;,&#39;direct&#39;); 修改文件夹权限 1chmod -R 777 ./wordpress 访问网址1http://ip/wordpress 站点配置调整修改apache配置使得访问网站时输入ip地址会自动跳转到 http://ip/wordpress (补充后面的子目录,不需要手动输入) 修改配置文件12345vim /etc/httpd/conf/httpd.conf添加如下RewriteEngine onRewriteCond %&#123;REQUEST_URI&#125; ^/$RewriteRule (.*) http://%&#123;SERVER_NAME&#125;/wordpress/ [L,R=301] 重启apache 1service httpd restart 重启 参考Centos 7 搭建 WordPress WordPress yum升级PHP版本到PHP7.2 wordpress切换语言/语言包 WordPress 安装主题、插件、更新时需要FTP的解决办法 apache2重定向至子目录]]></content>
  </entry>
  <entry>
    <title><![CDATA[cron表达式]]></title>
    <url>%2F2019%2F06%2F15%2Fcron%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[springboot中log4j的配置]]></title>
    <url>%2F2019%2F04%2F04%2Fspringboot%E4%B8%ADlog4j%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[springboot中log4j的配置]]></content>
  </entry>
  <entry>
    <title><![CDATA[一个简单maven项目的打包与运行]]></title>
    <url>%2F2019%2F03%2F24%2F%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95maven%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%89%93%E5%8C%85%E4%B8%8E%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[一个简单maven项目的打包与运行标题描述的不是很准确,应该说,一个包含外部依赖包的maven包的项目的打包以及运行. 创建maven工程目录结构如下 添加依赖包此处以fastjson为例,在pom.xml里添加依赖如下 123456789&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.15&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 编写demo1234567public class TestPackMain &#123; public static void main(String[] args) &#123; Map map = new HashMap(); map.put(&quot;a&quot;, &quot;b&quot;); System.out.println(JSON.toJSONString(map)); &#125;&#125; 打包 在pom.xml里添加如下打包配置 此处主要配置两点 jar包默认运行的main函数 编译时的java版本 1234567891011121314151617181920212223242526272829&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;pack.TestPackMain&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 执行打包命令 1package assembly:single 运行jar包 1java -jar maven-package-demo-1.0-SNAPSHOT-jar-with-dependencies.jar 控制台输出 1&#123;&quot;a&quot;:&quot;b&quot;&#125; 如果依赖的是内部的包,怎么办?//todo]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot中的拦截器与过滤器]]></title>
    <url>%2F2019%2F03%2F20%2Fspringboot%E4%B8%AD%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8%E4%B8%8E%E8%BF%87%E6%BB%A4%E5%99%A8%2F</url>
    <content type="text"><![CDATA[springboot中的拦截器与过滤器关于过滤器和拦截器的区别,在此不展开,仅仅记录下在一个springboot项目中如何配置生效过滤器以及拦截器 过滤器一般来讲,我们会使用FilterRegistrationBean来注册过滤器.使用流程如下: 定义过滤器123456789101112131415161718public class MyFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;doFilter&quot;); filterChain.doFilter(servletRequest, servletResponse); return; &#125; @Override public void destroy() &#123; &#125;&#125; 在这个过滤器中,我们仅仅是打印日志,之后将调用链接着传递 配置过滤器1234567891011@Configurationpublic class FilterConfig &#123; @Bean public FilterRegistrationBean CASFilter()&#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.addUrlPatterns(&quot;/*&quot;); Filter filter = new MyFilter(); registration.setFilter(filter); return registration; &#125;&#125; 注意Configuration和Bean注解的使用 注意过滤器的作用范围(registration.addUrlPatterns) 编写测试接口1234567@RestControllerpublic class TestController &#123; @RequestMapping(value = &quot;/test&quot;, method = RequestMethod.GET) public String test() &#123; return &quot;test&quot;; &#125;&#125; 调用测试接口可以看到控制台打印如下: 1doFilter 后记 过滤器经常被用在登录请求的校验中,也可以用在一些请求的加解密当中. 多个过滤器可以通过设置优先级达到确定执行顺序的目的. 拦截器自定义拦截器123456789101112131415161718public class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;preHandle&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion&quot;); &#125;&#125; 注意重载的preHandle的返回值,如果返回false,则请求不会接着往下走. 配置拦截器1234567@Configurationpublic class InterceptorConfig implements WebMvcConfigurer &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new MyInterceptor()); &#125;&#125; 调用测试接口可以看到控制台打印如下 1234doFilterpreHandlepostHandleafterCompletion 很直观的可以看到执行顺序. 后记关于拦截器和过滤器的区别,只能再仔细研究,再开一篇.]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot前后端分离实践]]></title>
    <url>%2F2019%2F03%2F19%2Fspringboot%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[springboot前后端分离实践前言现在很多项目都是采用springboot+react或者springboot+angularJs的模式进行开发,相对应的部署方式我认为主要有两种 打包后将前端静态文件放在resource下的文件夹里面 利用nginx的反向代理,将前端文件与后台程序分开部署. 而这两者中,我认为后者相对来说更好一些. 部署要点:nginx反向代理 安装nginx1yum install nginx 常用命令如下 1234nginx nginx -s stopnginx -s reloadnginx -t 默认配置文件位置 1/etc/nginx/nginx.conf 配置nginx重要:配置文件位置/etc/nginx/nginx.conf 配置前端文件目录在对应的server里配置 1root /usr/share/nginx/html 备注:默认为此,不需要设置 配置反向代理在对应的server里配置 123location /api/ &#123; proxy_pass http://localhost:8083/api/; &#125; 备注:此处的localhost:8083为springboot项目启动的机器ip和端口,也就是说前后端不需要部署在同一台机器上. 部署springboot1将springboot程序包部署启动 后记 很多人可能会有疑问,为什么要用反向代理呢?其实原因很简单:跨域.如果仅仅是将nginx作为前端的容器,然后由前端去直接请求springboot后台接口的话,是会有跨域问题的,这些请求是会被浏览器拦截的. 运用nginx的负载均衡,更进一步的话,我们可以在反向代理的时候通过nginx的upstream功能来实现负载均衡,可以指定轮询的策略.]]></content>
  </entry>
  <entry>
    <title><![CDATA[springboot数据库与mybatis]]></title>
    <url>%2F2019%2F03%2F18%2Fspringboot%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8Emybatis%2F</url>
    <content type="text"><![CDATA[springboot数据库与mybatis入门配置初始化工程参考链接:https://blog.csdn.net/typa01_kk/article/details/76696618 数据库配置以及测试在application.properties配置如下 12345678spring.datasource.url=jdbc:mysql://127.0.0.1:3306/testspring.datasource.username=rootspring.datasource.password=passwordspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.max-idle=10spring.datasource.max-wait=10000spring.datasource.min-idle=5spring.datasource.initial-size=5 通过jdbcTemplate的方式访问数据库 12345678910111213141516171819@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoSpringbootApplicationTests &#123; @Autowired JdbcTemplate jdbcTemplate; @Test public void contextLoads() &#123; String sql = &quot;select * from user&quot;; List&lt;Map&lt;String, Object&gt;&gt; resultList = jdbcTemplate.queryForList(sql); System.out.println(&quot;query result:&quot; + JSON.toJSONString(resultList)); for (Map&lt;String, Object&gt; item: resultList) &#123; for (Map.Entry&lt;String, Object&gt; entry: item.entrySet()) &#123; System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue().toString()); System.out.println(&quot;\n&quot;); &#125; &#125; &#125;&#125; 日志打印如下: 12345query result:[&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;test&quot;&#125;]id:1name:test 成功访问数据库. mybatis配置一般来讲,我们都是通过mybatis以及xml的方式访问数据库. 添加dao接口 12345678/** * @author wuweizhao * @version 创建时间：2019/3/18 9:26 PM */@Mapperpublic interface UserMapper &#123; List&lt;Map&gt; querUser();&#125; 添加mapper.xml文件(文件位置:resources/mapper/UserMapper.xml) 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.example.demospringboot.dao.UserMapper&quot;&gt; &lt;select id=&quot;querUser&quot; resultType=&quot;java.util.Map&quot;&gt; SELECT id, name FROM user &lt;/select&gt;&lt;/mapper&gt; 添加配置信息(application.properties) 1mybatis.mapper-locations=classpath:mapper/**/*.xml 编写测试代码 123456@Autowired UserMapper userMapper; @Test public void testMybatis() &#123; System.out.println(JSON.toJSONString(userMapper.querUser())); &#125; 查看控制台打印信息 1[&#123;&quot;name&quot;:&quot;test&quot;,&quot;id&quot;:1&#125;] 完整的application.properties配置文件如下 12345678910111213spring.datasource.url=jdbc:mysql://127.0.0.1:3306/testspring.datasource.username=rootspring.datasource.password=passwordspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.max-idle=10spring.datasource.max-wait=10000spring.datasource.min-idle=5spring.datasource.initial-size=5server.port=8083server.tomcat.uri-encoding=UTF-8mybatis.mapper-locations=classpath:mapper/**/*.xml 完整的pom.xml文件如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;demo-springboot&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;demo-springboot&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 参考 https://blog.csdn.net/typa01_kk/article/details/76696618 https://blog.csdn.net/zhoujiyu123/article/details/79786847]]></content>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于java 中的equals的一些记录]]></title>
    <url>%2F2018%2F10%2F21%2F%E5%85%B3%E4%BA%8Ejava-%E4%B8%AD%E7%9A%84equals%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[override equals方法的几个原则 自反性。对于任何非null的引用值x，x.equals(x)应返回true。 对称性。对于任何非null的引用值x与y，当且仅当：y.equals(x)返回true时，x.equals(y)才返回true。 传递性。对于任何非null的引用值x、y与z，如果y.equals(x)返回true，y.equals(z)返回true，那么x.equals(z)也应返回true。 一致性。对于任何非null的引用值x与y，假设对象上equals比较中的信息没有被修改，则多次调用x.equals(y)始终返回true或者始终返回false。 示例代码(String类的equals方法): 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; list中的indexOf,contains方法根据equals方法来判断对象是否相等 override hashCode方法从Object类中的源码可以看到重载equals之后需要重载hashCode的提示 123If two objects are equal according to the &#123;@code equals(Object)&#125;* method, then calling the &#123;@code hashCode&#125; method on each of* the two objects must produce the same integer result. String 类的hashCode代码: 123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; Map接口会使用,可以简单理解为通过hashCode方法算出该变量的地址,那么当两个变量相等,那么这个算出来的hashCode也势必需要相等. 编写equals的建议下面给出编写一个完美的equals方法的建议（出自Java核心技术 第一卷：基础知识）： 显式参数命名为otherObject,稍后需要将它转换成另一个叫做other的变量（参数名命名，强制转换请参考建议5） 检测this与otherObject是否引用同一个对象 ：if(this == otherObject) return true;（存储地址相同，肯定是同个对象，直接返回true） 检测otherObject是否为null ，如果为null,返回false.if(otherObject == null) return false; 比较this与otherObject是否属于同一个类 （视需求而选择） 如果equals的语义在每个子类中有所改变，就使用getClass检测 ：if(getClass()!=otherObject.getClass()) return false; (参考前面分析的第6点) 如果所有的子类都拥有统一的语义，就使用instanceof检测 ：if(!(otherObject instanceof ClassName)) return false; 将otherObject转换为相应的类类型变量：ClassName other = (ClassName) otherObject; 现在开始对所有需要比较的域进行比较 。使用==比较基本类型域，使用equals比较对象域。如果所有的域都匹配，就返回true，否则就返回flase。 如果在子类中重新定义equals，就要在其中包含调用super.equals(other) 当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明 相等对象必须具有相等的哈希码 。 参考equals解读]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https-nginx配置]]></title>
    <url>%2F2018%2F10%2F17%2Fhttps-nginx%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[转载https://bitmingw.com/2017/02/02/letsencrypt-tutorial/]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>https</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试https图床]]></title>
    <url>%2F2018%2F06%2F23%2F%E6%B5%8B%E8%AF%95https%E5%9B%BE%E5%BA%8Aimgur%2F</url>
    <content type="text"><![CDATA[https图床 在给网站添加了https之后,发现访问的时候依然处于不安全的状态,查看提示之后才知道是七牛图床的协议导致的 在页面上存在http的链接的时候,浏览器仍然会提示不安全. 为了访问页面时的小绿锁,势必得寻找一个https的图床了. 七牛云是有提供https支持的,只是需要在七牛云添加备案后的域名,由于网站并不打算备案,所以这条路就行不通了 国内的其他一些有提供https图床的服务又有点不靠谱,说不定哪天就跑路了呢 微博的图床服务似乎也不是很稳定 imgur,这个又有被墙的风险 腾讯云对象存储,这个似乎比较靠谱一些,只是没有一些比较趁手的工具 估计还是得用imgur吧,或者用腾讯云,再或者就是尽量采用代码以及描述性的文字来写博客吧(┓( ´∀` )┏) imgur图片测试 腾讯云对象存储]]></content>
  </entry>
  <entry>
    <title><![CDATA[session与cookie]]></title>
    <url>%2F2018%2F02%2F07%2Fsession%E4%B8%8Ecookie%2F</url>
    <content type="text"><![CDATA[session与cookiecookie 在服务端中设置,在前端中需要看情况 当设置了httponly时,仅能在服务端设置,js端既不能读取也不能够设置. 无设置httponly时,前端也可以设置和读取cookie的值 session 需要注意的是,session指的是”对话” req.getSession().setAttribute(&quot;session&quot;, &quot;value&quot;); 按照如上的代码, req.getSession().getAttribute(&quot;session&quot;) 就可以获得value值 可以想象成服务器维持了一个map,map的key是sessionID,而值则是一个个的键值对,而sessionID的传递方式则是通过cookie来实现的(在初始化session时会生成并且设置cookie,而之后cookie的提交则会带上sessionID) 除此之外,在禁用cookie的情况下,还能通过url重写的方式来实现sessionID的传递 在分布式部署的情况下,session的同步是一个问题,比较简单的解决方式是使用spring session+redis实现.]]></content>
      <tags>
        <tag>java</tag>
        <tag>java web</tag>
        <tag>session</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-scrapy]]></title>
    <url>%2F2018%2F01%2F28%2Fpython-scrapy%2F</url>
    <content type="text"><![CDATA[scrapy爬虫框架入门 安装 开始项目以及创建爬虫(参照命令行工具) scrapy startproject myproject //初始化项目 cd myproject scrapy genspider mydomain mydomain.com //创建spider 项目的文件目录以及功能 item.py: 数据格式的定义 (爬虫名称).py: 具体的爬虫逻辑 pipelines.py: 对爬虫得到的数据(item进行处理) settings.py: 对爬虫的一些定义(比如指定pipelines等) 除此之外,比较实用的命令还有 以给定的URL(如果给出)或者空(没有给出URL)启动Scrapy shell,运行之后你可以在命令行中使用response选择器,这样就可以进行网页页面的分析而不用每次都启动spider scrapy shell &quot;url&quot; ....略过执行代码 response.xpath(&quot;//h1[@class=&apos;post-title&apos;]/a&quot;) //选择器 运行指定的spider scrapy crawl &lt;spider&gt; -o 输出的文件 * 更多的命令可以查看[http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/commands.html](http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/commands.html) 自定义爬虫item(items.py) import scrapy class TutorialItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() title = scrapy.Field() link = scrapy.Field() # pass 定义爬虫逻辑(爬虫名称.py) class WuweizhaoSpider(scrapy.Spider): name = &apos;wuweizhao&apos; allowed_domains = [&apos;wuweizhao.com&apos;] start_urls = [&apos;http://wuweizhao.com/&apos;] def parse(self, response): list = response.xpath(&quot;//h1[@class=&apos;post-title&apos;]/a&quot;) url = &quot;http://wuweizhao.com/&quot; for a in list: yield scrapy.Request(url + a.xpath(&quot;./@href&quot;)[0].extract(), callback=self.parse_contents) next_page = response.xpath(&quot;//nav/a[@class=&apos;extend next&apos;]/@href&quot;).extract_first() if next_page is not None: next_page = url + next_page print(next_page) next_page = response.urljoin(next_page) yield scrapy.Request(next_page, callback=self.parse) def parse_contents(self, response): item = TutorialItem() item[&quot;title&quot;] = response.xpath(&quot;//h1[@class=&apos;post-title&apos;]/text()&quot;).extract_first().replace(&quot;\n&quot;, &quot;&quot;).strip() item[&quot;link&quot;] = response.request.url yield item start_urls爬虫启动时访问的url yield关键字: 新的Request:会将url加入到访问队列当中 item(继承scrapy.Item的类):输出到命令行或者相应的文件当中(根据启动参数而定) 自定义item处理(如果有需要的话) 修改settings.py中的选项ITEM_PIPELINES 修改pipelines.py class TutorialPipeline(object): def __init__(self): pass def process_item(self, item, spider): return item 参考http://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/overview.htmlhttp://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/selectors.html]]></content>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-tips]]></title>
    <url>%2F2018%2F01%2F28%2Fpython-tips%2F</url>
    <content type="text"><![CDATA[python-tips列表生成式 Python内置的非常简单却强大的可以用来创建list的生成式 写列表生成式时，把要生成的元素x * x放到前面，后面跟for循环，就可以把list创建出来 生成器 当我们需要创建100万个元素的列表的时候,如果这些元素可以按照一定的规则去生成,那么我们就不需要在内存中同时维护这100万个元素,而是通过在迭代中边去生成元素来实现. 把一个列表生成式的[]改成()，就创建了一个generator 需要注意的是,我们一般不会显式调用next方法,而是使用for in迭代 如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。 generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。]]></content>
      <tags>
        <tag>python</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servletRequest中读取body的问题]]></title>
    <url>%2F2018%2F01%2F26%2FservletRequest%E4%B8%AD%E8%AF%BB%E5%8F%96body%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ServletRequest中读取body的数据InputStream body = request.getInputStream(); 问题 数据流仅仅能够读取一次,如果你想要多次读取(在多个调用链中)(比如说在多个过滤器中),例如 chain.doFilter(request, response); 这样后面的调用中request将读取不到body的数据. 解决 继承实现HttpServletRequest接口的HttpServletRequestWrapper,重载getInputStream方法. 具体实现BufferedServletRequestWrapper类public class BufferedServletRequestWrapper extends HttpServletRequestWrapper { private byte[] buffer; public BufferedServletRequestWrapper(HttpServletRequest request) throws IOException { super(request); InputStream is = request.getInputStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte buff[] = new byte[ 1024 ]; int read; while( ( read = is.read( buff ) ) &gt; 0 ) { baos.write( buff, 0, read ); } this.buffer = baos.toByteArray(); } @Override public ServletInputStream getInputStream() throws IOException { return new BufferedServletInputStream( this.buffer ); } } 在过滤器中ServletRequest requestWrapper = new BufferedServletRequestWrapper(req); InputStream inputStream = requestWrapper.getInputStream(); String content = IOUtils.toString(inputStream, req .getCharacterEncoding()); /**对内容进行处理**/ chain.doFilter(requestWrapper, response); /**由于我们在初始化时保存了byte,重载了getInputStream方法,所以后续调用时可以获得body中的数据**/]]></content>
      <tags>
        <tag>java web</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSRF浅析]]></title>
    <url>%2F2018%2F01%2F24%2FCSRF%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[CSRF浅析什么是CSRFCross-site request forgery,跨站请求伪造. 简单的攻击样例 小明访问并且登录了网站A 小明访问坏人的网站B,网站B上存在一些网站A的请求(GET或者POST) 一个简单的get请求可以利用img的src属性: &lt;img src=&quot;http://example.com/get?xxx=xxx&quot;&gt; 访问时触发了请求,此时由于请求中携带着相关的cookie信息,所以网站A是会通过这些非法的请求的,也就是跨站(在黑客网站B)请求伪造. 预防referer验证这是一种不安全的校验方法 校验原理对于网络请求,在header里面存在着referer属性,这个属性标识出请求的来源网站,所以我们可以通过验证referer来预防csrf攻击 存在问题 对于某些浏览器来说,这个属性可能为空 referer可以轻易地伪造 从搜索引擎跳转时,referer是搜索引擎,所以可能需要维护一个白名单 双提交cookie较为安全 实现对于每一个网络请求,在提交请求时,在js中将cookie中的某些值(可以是单独生成的token或者用户标志灯)添加到header上提交,在后台去校验是否存在token以及是否与cookie的值相匹配 原理当你在访问坏人的网站B时,同时提交的仅仅只有cookie,而你在正常访问时,提交时会在header中添加csrftoken. 问题其实也不能算是问题吧,如果你的网络请求是统一到一个方法里面执行的,例如说ajax或者dwr,那么就可以很方便地修改,但是如果不是的话,那么修改的工作量可能就有点大了. 参考https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html]]></content>
      <tags>
        <tag>web安全</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web线程安全]]></title>
    <url>%2F2018%2F01%2F24%2Fweb%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[java web中的线程安全问题问题描述:伪代码:判断redis是否有相应的键值对: 有: 读取redis 没有: 读取数据库 插入redis(列表的插入) 返回 问题当请求并发时,第一个请求redis未插入而第二个请求也进入了判断,此时第二个请求的判断条件也是”否”,所以就会出现redis数据重复的情况. 原因虽然说对于每一个单独的请求,spring都是新建一个单独的线程来进行处理,但是这并不能够解决上面的问题,究其原因,则是访问了同一个全局数据(可以认为是redis) 解决:增加一个全局变量,使用synchronize同步方法,伪代码如下 伪代码全局变量 lock 判断redis是否有相应的键值对: 有: 读取redis 没有: synchronize(lock) 再次判断redis是否有相应的键值对 有: 读取redis 没有: 读取数据库 插入redis 再次判断的原因:加锁只是阻塞了第二个请求的读取数据库/插入redis操作,如果没有再次判断的话,那么当第一个请求释放锁之后第二个请求依旧会再次读取数据库/插入redis,问题依旧存在 参考http://www.cnblogs.com/doit8791/p/4093808.html]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域请求]]></title>
    <url>%2F2017%2F11%2F14%2F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[跨域资源请求CORS1.什么是跨域资源请求 通常情况下,我们访问一个网站的过程如下: 访问页面example.com,加载页面html以及js 对页面进行一些操作,由js通过ajax访问后台,进行页面的更新. 一般情况下,通过ajax调用后台是同源的,同源指的是: 协议相同 端口号相同 地址相同 但是有时候通过js请求非同源的后台服务,这个时候就是属于跨域资源请求了 2.问题 由于Ajax的同源设置策略,所以如果我们直接请求非同源的地址的话,会出现错误 3.解决方法1. 作为用户 安装chrome插件Allow-Control-Allow-Origin后启用即可.2.作为开发者 当浏览器发现ajax请求是跨域请求时,会在请求头上面添加origin字段,这个字段将作为服务器指定是否允许同源请求的地址 在服务器上,我们需要配置web.xml中SpringServlet的初始化参数,如下 其中,CrosbyFilter代码如下: public class CrosFilter implements ContainerResponseFilter { @Override public ContainerResponse filter(ContainerRequest creq, ContainerResponse cres) { cres.getHttpHeaders().add("Access-Control-Allow-Origin", "*"); cres.getHttpHeaders().add("Access-Control-Allow-Headers", "Content-Type, msgversion"); cres.getHttpHeaders().add("Access-Control-Allow-Credentials", "true"); return cres; } } 需要注意的是头部添加的三个值: Access-Control-Allow-Origin:其值为允许跨域访问的源地址,可以为*匹配所有或者具体的源地址 Access-Control-Allow-Headers:CORS请求时,XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定,如上面代码所示,在返回里面添加了msgversion的头部信息,如果不需要额外信息此项可不写 Access-Control-Allow-Credentials:表示是否允许发送Cookie,这个值也只能设为true，如果服务器不要浏览器发送Cookie，不要添加该字段即可 修改之后,跨域访问时可以看到返回的内容为:3.总结 总的来说,简单跨域请求主要的操作是还是在服务器端进行操作,大部分浏览器都能够自动地进行跨域的访问,上面所提到的也仅仅是简单的跨域资源请求,更多的资料可以去查看http://www.ruanyifeng.com/blog/2016/04/cors.html jQuery中ajax请求的跨域问题最近用到了百度地图的web api,想要通过ajax get来获得内容,没想到都跨域了.解决方法如下(其中success的值为自定义的回调函数) var options = { type: &quot;get&quot;, dataType:&quot;jsonp&quot;, jsonp:&quot;callback&quot;, url: serviceURL, //dataType: &apos;json&apos;, timeout: timeout || 20000,//超时时间设置，单位毫秒 success: callBack }; $.ajax(options); 原理JSONP参考http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html中JSONP部分内容 局限jsonp只能是解决get方法的跨域问题,如果是post的话,还是需要修改服务器的相关内容(参照上面解决方法中开发者的部分)]]></content>
      <tags>
        <tag>http</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入剖析tomcat笔记]]></title>
    <url>%2F2017%2F10%2F30%2F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90tomcat%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[servlet reponse request 启动连接器-&gt;等待连接-&gt;调用container容器-&gt;解析header,调用servlet]]></content>
  </entry>
  <entry>
    <title><![CDATA[Maven实战读书笔记]]></title>
    <url>%2F2017%2F10%2F11%2FMaven%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Maven实战常用命令 mvn clean compile mvn clean test mvn clean package 默认打包为jar,可以在pom.xml里面指定打包类型 mvn clean install 将项目打包后安装到本地仓库以供其他项目使用 默认打包生成的jar时不能够直接运行的,为了生成可执行的jar文件,需要借助maven-shade-plugin]]></content>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术卷读书笔记]]></title>
    <url>%2F2017%2F10%2F11%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Java核心技术卷(一)读书笔记数据类型整型 int 4字节 long 8字节 short 2字节 byte 1字节 需要注意的是字节长度与平台无关,与c语言不同 浮点型 float 4字节,一般不够用 double 8字节 遵循IEEE754标准 char类型 16位,字符常量,用单引号括起来 16位,65536个不同的值 一个char代表一个代码单元,但是并不一定代表一个代码点. 一个代码点可以认为是一个字符,例如’a’,’中’,但是其中可能前者只包含一个代码单元,而后者包含两个代码单元 boolean 类型字符串 String类型 与C,C++不同的是,字符串并非是字符数组,也不提供修改字符串的方法,其目的在于编译器可以让字符串共享,因为各种字符串存在一个公共的存储池当中. 使用equals方法来判定是否相等 length方法:返回的是字符长度,也就是代码单元数量 getBytes().length() 可以返回字节长度,需要指定编码方式. 通过StringBuilder来构建字符串 面向对象 依赖 use a 聚合 has a 继承 is a 一个对象变量并不拥有一个对象,而仅仅是引用一个对象 final变量:构建对象时必须初始化final变量,但是并不意味着此变量不能被改变,而仅仅意味着变量的引用不能够改变,但是如果引用的对象是不可变对象时(例如String),则可以认为此变量是不能够被改变的 static变量:静态变量,类级别共享的变量 方法参数,注意到java总是按照值传递的方式调用函数(call by value) 静态初始化块,在类第一次加载的时候将会进行静态域的初始化继承 final类和方法可以阻止继承,以免子类改变语义 只能在继承层次进行类型转换,同时在进行(继承链)向下的转换时,先用instanceof进行类型判断方法调用 动态绑定 查看对象的声明类型和方法名称 查看调用方法时提供的参数类型 非静态绑定时采用动态绑定的方式调用方法,调用的方法依赖于隐式参数(this)的实际类型. 调用与对象的实际类型最适合的类方法. 为了减少每次搜索的开销,编译器维护一个方法表,其中列出了所有方法的签名和实际调用的方法 静态绑定 private方法 static方法 final方法 equals方法的几个特性 自反性 a.equals(a) 为true 对称性 传递性 一致性:反复调用应该返回一样的结果 x.equals(null) 返回false hashcode方法 一个hash方法,由对象导出的一个整型,每个对象都有一个默认的hashcode,其值为对象的存储地址 equals和hashCode的定义必须一致:调用的返回结果必须相同 反射 Class类:表示一个特定类的属性,具体而言,Class是一个类,而某个具体类的class(例如int.Class)则是对象,其类是Class. newInstance()方法初始化对象 getFields():返回public 域数组 getMethods() getConstructors() todo 动态绑定 todo instanceof equals hashCode 枚举类 反射 克隆 内部类]]></content>
      <tags>
        <tag>java</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的面向对象程序设计]]></title>
    <url>%2F2017%2F08%2F28%2FJavaScript%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[JavaScript中的面向对象程序设计1.最简单的模式1.1 新建实例添加属性和方法var person = new Object(); person.name = &quot;name&quot;; person.sayHi = function() { console.log(&quot;hi&quot;); } console.log(person.name); person.sayHi(); 1.2 对象字面量 与上面的方法其实是相同的,仅仅是书写上简化了一些而已. var person = { name : &quot;name&quot;, sayHi : function() { console.log(&quot;hi&quot;); } } 如果你要构造多个对象的话,那么以上的模式的问题就显而易见了:产生大量的重复代码,而函数就是解决重复代码的利器. 2.工厂模式function createPerson() { var o = { name : &quot;name&quot;, sayHi : function() { console.log(&quot;hi&quot;); } } return o; } 3. 构造函数模式function Person(name) { this.name = name; this.sayHi = function() { console.log(&quot;hi&quot;); } } person = new Person(&quot;name&quot;); 使用构造函数模式新建对象时,经历了以下的四个步骤: 创建一个新对象 将构造函数的作用域赋给新对象(this关键字指向创建的新对象) 执行构造函数中的代码 返回新对象 关于this 的具体含义,可以参考阮一峰的网络日志-Javascript的this用法 现在我们解决了构造多个对象时的重复代码问题,但是其实还有另外一个问题:每一个方法都需要在每个实例上重新创建一遍,而原型模式可以解决这个问题. 4. 原型模式4.1 原型 每个函数都有prototype(原型)属性,这个属性指向一个原型对象,而这个对象为所有实例共享(包括对象里面的属性以及方法). 值得注意的是,在实例中的变量会屏蔽掉原型模式中的同名变量.4.2 使用 function Person(name) {this.name = name; this.sayHi = function() { console.log(&quot;hi&quot;); } } Person.prototype.sayName = function() {console.log(this.name) }; 或者我们也可以通过对象字面量的方式来实现: Person.prototype = { constructor: Person, a: &quot;a&quot; } 4.3 问题随着共享随之而来的问题是:对共享变量的修改可能会影响到你的预期输出结果,所以使用时还请慎重. 5. 混合使用原型模式和构造函数模式function Person(name) { this.name = name; this.sayHi = function() { console.log(&quot;hi&quot;); } } Person.prototype = { constructor: Person, a: &quot;a&quot; } 继承function SuperType() { this.property = true; } SuperType.prototype.getSuperValue = function() { return this.property; } function SubType() { this.subproperty = false; } SubType.prototype = new SuperType(); SubType.prototype.getSubValue = function() { return this.subproperty; } var instance = new SubType(); alert(instance.getSuperValue());]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis入门以及整合spring]]></title>
    <url>%2F2017%2F08%2F23%2Fmybatis%E5%85%A5%E9%97%A8%E4%BB%A5%E5%8F%8A%E6%95%B4%E5%90%88spring%2F</url>
    <content type="text"><![CDATA[mybatis入门什么是mybatis MyBatis是一个Java持久化框架，它通过XML描述符或注解把对象与存储过程或SQL语句关联起来(from维基百科)准备工作 mybatis的jar包 一个数据库(我采用的是mysql)具体如下数据库结构如下 my-batis文件 配置文件,配置连接的数据库,账户名,密码等,同时指定使用到的mapper的位置 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://127.0.0.1:3306/db_develop&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;password&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper url=&quot;file:///F:/IDEAProject/WebAppLearn/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; mapper文件 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.wilbert.mapper.UserMapping&quot;&gt; &lt;select id=&quot;getUser&quot; resultType=&quot;com.wilbert.model.User&quot;&gt; select * from tb_user where id = #{id} &lt;/select&gt; &lt;/mapper&gt; 注意其中的namespace,命名空间,可以将其认为是java中的包,而id则为java中具体的类,这样在下面的调用就比较好理解了. 数据模型类,一个普通的java类,拥有getter,setter方法. 测试类 public class MyBatisLearn { public static void main(String[] args) throws IOException { String resource = &quot;src/main/java/com/wilbert/config/mybatis-config.xml&quot;; InputStream inputStream = new FileInputStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); String statement = &quot;com.wilbert.mapper.UserMapping.getUser&quot;; User user = sqlSession.selectOne(statement, &quot;5b6f8d5739834dddb785c5e909471e69&quot;); } } 需要注意的是statement,statement是由namespace+id构成. 运行结果 id:5b6f8d5739834dddb785c5e909471e69,name:a,password:a 后续 从上面可以看到,其中至关重要的是mapper文件,在mapper文件中我们配置了各式各样的sql,而mybatis也提供了很强大的语法来实现复杂的查询或者插入,更新等.详情可以进一步查看http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html 参考资料:http://www.mybatis.org/mybatis-3/zh/getting-started.html]]></content>
      <tags>
        <tag>mybatis</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA NIO]]></title>
    <url>%2F2017%2F08%2F23%2FJAVA-NIO%2F</url>
    <content type="text"><![CDATA[参考资料:https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html 主要概念: 通道(channel) 缓冲区(buffer) 主要思想: 在原来的IO的思想上封装,提高IO效率 方法: 通过缓冲区实现基于块的读写 具体: 先获得文件的输入输出流–&gt;从文件的输入输出流获得通道(channel)–&gt;分配缓冲区(buffer)–&gt;从缓冲区中读取内容/将内容写入缓冲 缓冲区内部细节:缓冲区的底层实现可以看成是一个字节数组, 三个变量 position:当前索引,也可以理解为指针所指的元素,初始值为0,指向第一个元素 limit:初始值为capacity,通过与position以clear函数和flip函数结合来确定写入写出的元素. capacity:总容量,可以理解为数组长度,limit&lt;=capacity flip函数1.将limit设置为position的值2.将position设置为0将buffer写入到输出通道时,调用此函数,注意在写入到输出通道时(foutchanel.write(buffer)),position会步进,而limit不变,所以想要循环读取时,需要调用clear函数重置缓冲区的状态. clear函数1.将limit设置为capacity的值2.将position设置为0 文件输入输出流会记住输入输出的位置,每个字节仅能被读取一次.]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java高级程序设计之面向对象]]></title>
    <url>%2F2017%2F08%2F01%2FJava%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[Java高级程序设计之面向对象对象使用对象字面量来创建对象 对于对象的每一个属性来说,,都有两种类型的属性来确实其性质: 数据属性 Configureable 是否可配置,该属性指定对象是否可以配置(主要指的是数据属性) Enumerable 是否可遍历,指定for in时是否返回 Writable Value 属性的数据值,例如person中的属性name的值wilbert 访问器属性 Configureable 是否可配置,该属性指定对象是否可以配置(主要指的是数据属性) Enumerable 是否可遍历,指定for in时是否返回 Writable Value 属性的数据值,例如person中的属性name的值wilbert Get Set var person = { name: &quot;wilbert&quot;, sayHello: function () { console.log(&quot;hello!world!&quot;) } } Object.defineProperty(person, &quot;name&quot;, { get: function () { return name + &quot;test&quot;; }, set: function (newValue) { name = newValue; } }) person.name = &quot;abcd&quot;; console.log(person.name); //输出 abcdtest 注意,仅能通过Object.defineProperty()或者Object.defineProperties()方法来对上述属性进行修改. 工厂模式 使用一个普通的函数,在函数中新建Object并且设定其属性,之后返回这个对象构造函数模式 function Person(name, password) {this.name = name; this.password = password; this.sayHello = function () { console.log(&quot;Hello!&quot;); } } person = new Person(‘a’, ‘a’); 使用new操作符来创建对象可以使用instanceof来判断对象类型 构造函数也可以看成普通的函数来调用,注意此时的this的作用域(一般情况下是windows) 缺点:每个方法都相当于重新实例化了一遍,这个问题可以通过原型模式property解决原型模式 每个构造函数都存在着prototype属性,这个属性指向一个原型对象,默认原型对象仅有constructor属性,constructor属性中又存在着指向构造函数的指针,如图 而通过构造函数实例化的对象都存在一个无法访问的指针[[prototype]]指向同一个原型对象. 指针的获得方式 Object.getPrototypeof(person) 所以我们可以通过构造函数的prototype属性来设置原型对象从而达到公用函数或者变量的目的. 注意,访问一个对象的属性时的访问顺序:先访问自身的值,如果不存在,再访问原型对象中的值. 动态原型模式看代码 function Person(name, password) { this.name = name; this.password = password; if(typeof this.sayHello != &quot;function&quot;) { Person.prototype.sayHello = function () { console.log(this.name + this.password); } } } 结合了构造函数与原型模式的优点,使其在使用上与普通的C/C++系的类更加相同. 继承顺着上面的原型链继续写点关于继承的内容. 实现方法:设置子类(SubType)的原型属性(prototype)为父类(SuperType)的实例. 大概原理 图片 代码大致如下 function Man(age) { this.age = age; this.name = &quot;test sub&quot;; } Man.prototype = new Person(&quot;sub&quot;, &quot;sub&quot;); man = new Man(&quot;10&quot;); man.sayHello(); //访问Person类的方法 console.log(man.name); //访问Person类的属性 此时情况如下: man中的[prototype]指向Person(父类)的实例对象person person类中的[prototype]指向Person(父类)的原型对象 Person(父类)的原型对象的Constructor中存在指向Person的指针 综上,构成了一条原型链,而根据属性的访问规则: 访问一个对象的属性时的访问顺序:先访问自身的值,如果不存在,再顺着原型链直至查找到对象为止. 重点在于 构造函数存在prototype指向原型对象; 默认原型对象的构造函数存在指向构造函数的指针; 对象实例(通过构造函数创建)存在指向原型对象的指针. 可以通过 instanceOf判断类型 给原型添加方法的代码一定要放在替换原型的语句之后.]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL记录(二)]]></title>
    <url>%2F2017%2F07%2F31%2FSQL%E8%AE%B0%E5%BD%95-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[聚集函数MIN()MAX()AVG()SUM() COUNT() 函数 count(*) 将对表中行的数目进行计数 count(column) 会略过值为null的列tips*可以使用distinct关键字仅指定不同值的行. select count(distinct column)….. 分组数据关键字: Group by 根据指定的列来进行分组 select cID, count(*) as numberfrom ProductsGroup by cID; 根据cID进行分组,返回cID以及相对应的数目 除了聚集计算语句之外,select的每个字段必须为分组的依据(出现在group by之后) group by 出现在where子句之后,order by之前. Having 筛选分组 HAVING和WHERE的区别在于一个是在分组之前过滤(where,不符合条件的记录不参与分组),一个是在分组之后进行过滤(HAVING).联结 join 等值联结,又称内联结 inner join on where … =]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript高级程序设计笔记]]></title>
    <url>%2F2017%2F07%2F18%2Fjavascript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[使用var定义的变量为局部变量 省略var定义的变量为全局变量 五种简单数据类型 Undefined 声明变量但是未初始化时变量的值 Null 表示一个空对象的指针,在变量还没有真正保存对象时,应该明确让其保存null值. Boolean 任何非空字符串为真 任何非零数字值为真,0和NaN为假 Number isNaN() 函数确实一个值是否”不是数值”,注意其判断的过程会检测其toString的值,例如isNaN(‘1’)返回false(意思是’1’是一个数字) parseInt函数 String 复杂数据类型 Object 变量,作用域和内存问题 在if以及for语句中定义的变量在循环执行结束后依旧存在. Array数组的使用//todo 创建数组的几种不同方式 var colors = new Array() var colors = new Array(3) var colors = new Array(‘A’, ‘B’) var colors = [] 注意,数组的length属性的动态性,可以通过直接设置其值来达到动态调整数组长度的目的 Array.isArray(colors)方法判断是否是数组 concat方法拼接返回新的数组 slice方法 一个参数时返回开始位置直至结束的数组 两个参数时返回指定位置之间的数组(包含开始但不包含结束位置的项 splice方法 参数一:删除的第一项的位置 参数二:删除的项数 参数三,四,…n:插入的值 indexOf方法,从头开始查找,不存在返回-1 lastIndexOf,从结尾开始查找,不存在返回-1 迭代方法 every() filter() forEach() map() some() 注意,迭代方法的参数均为一个函数,此函数的参数为(item,index,array) 缩小方法(进行数组的迭代求和等) reduce(function(prev, cur, index, array) {}) reduceRight(function(prev, cur, index, array) {}) Date类型的使用 //todo]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL记录(一)]]></title>
    <url>%2F2017%2F07%2F17%2FSQL%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[distinct关键字 通过distinct让数据库只返回不同的数值,注意,当查询多列数字时,只有当所有列内容相同才会视其为相同的数值. 使用时,将distinct关键字置于列名之前. order by 排序 应该保证order by子句是select语句中的最后一条子句,否则将会报错. 可以使用非选择的列进行排序 可以选择按照多个列进行排序,排序优先级按照出现顺序,也就是说先按照a条件排序,当a条件相同时在按照b条件进行进一步的排序. desc 逆序排列,注意此关键字只作用在其指定的列上(与之不同的是distinct关键字,它作用于选择的所有列上),也就是说,如果按照两列的逆序排列的话,你需要分别在这两列列名后使用desc where 筛选 范围值检查,使用between and操作符 空值检查 IS NULL子句(注意,不能够使用 =NULL) 空值指的是NULL,而非存在值但是值为0 AND OR关键字 注意两者的求值顺序,总是使用括号来显示指定求值顺序 IN (… , …) 实现与OR操作符类似的功能 NOT 进行否定,一般多用于 NOT IN() LIKE操作符 通配符搜索只能用于文本字段 % 通配符 表示任何字符出现任何次数(包含0次) _ 仅匹配单个字符 [] 指定字符集,与正则表达式类似,只是它总是刚好匹配指定字符集之中的一个字符.例如[JM],使用[^JM]表示除了JM之外的任一字符. 计算字段 拼接字段 连接 || 连接 TRIM()/LTRIM()/RTRIM()函数:去除空格 算术计算 AS 别名 将计算字段或者某一个已有的字段(即列)重命名为其他值并且返回]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo第三方服务添加]]></title>
    <url>%2F2017%2F07%2F16%2Fhexo%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1%E6%B7%BB%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[通常来讲为next主题添加第三方服务(例如添加评论系统,使用百度统计,腾讯分析等)的过程都是类似的: 注册网站,获得相应的appID或者key 在主题的配置文件中设置相应的appID或者key 重新生成并部署hexo即可 leancloud为next主题添加统计信息搜索功能添加 采用了next主题提供的local search功能 来必力评论系统添加参考next主题第三方服务添加]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu下编译安装nginx]]></title>
    <url>%2F2017%2F04%2F13%2Fubuntu%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85nginx%2F</url>
    <content type="text"><![CDATA[Ubuntu下编译安装nginx 参考这里 安装完成之后，编辑修改nginx.conf， 路径是 /usr/local/nginx/conf/nginx.conf 启动nginx sudo /usr/local/nginx/sbin/nginx 关闭nginx sudo /usr/local/nginx/sbin/nginx -s stop 重读nginx配置文件 sudo /usr/local/nginx/sbin/nginx -s reload]]></content>
      <tags>
        <tag>ubuntu</tag>
        <tag>nginx</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vps+git+hexo+nginx搭建博客网站]]></title>
    <url>%2F2017%2F04%2F13%2Fvps-git-hexo-nginx%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[vps+git+hexo+nginx搭建博客网站由于科学上网的需要，买了一个vps，想着单单用来ss似乎不太值，所以就想说搭建一个简单的博客系统，wordpress比较繁杂，所以就采用了这样的一个方式来搭建博客：git+hexo（主题：next）+nginx，实现思路大概是这样子的： 在本地windows上搭建hexo，编写博客之后hexo generate，生成html文件 在vps上搭建git服务器，nginx服务 将本地html文件更新到服务器上 使用git hook功能将服务器git目录更新到网页文件上 windows上搭建hexo官方文档安装完成。 vps安装git服务安装gitsudo apt-get install git 创建git用户sudo adduser git 初始化git仓库，存放目录 /var/repo/sudo mkdir /var/repo cd /var/repo sudo git init --bare blog.git 创建git hooks创建自定义钩子,指定特定的重要动作发生时触发自定义脚本,创建的是服务端钩子 post-receive，具体内容可以查看这里 cd /var/repo/blog.git/hooks vim post-receive 在post-receive加入如下内容 #!/bin/sh git --work-tree=/var/www/hexo --git-dir=/var/repo/blog.git checkout -f 注意，其中/var/www/hexo目录是您的nginx的网站目录，请根据需要进行修改 修改文件的可执行权限 chmod +x post-receive 改变 blog.git 目录的拥有者为 git 用户：sudo chown -R git:git blog.git vps安装nginx服务见这里 windows本地配置修改hexo目录下的_config.yml文件中的deploy deploy: type: git repo: git@weizhaowu.me:/var/repo/blog.git branch: master 具体的使用hexo new &quot;new-post&quot; hexo clean &amp;&amp; hexo generate --deploy 这样博客就会自动更新到网站上面了。 参考使用 Git Hook 自动部署 Hexo 到个人 VPS]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>nginx</tag>
        <tag>vps</tag>
        <tag>git</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[by以及having的使用]]></title>
    <url>%2F2016%2F10%2F28%2Fsql%E4%B8%ADgroup%20by%E4%BB%A5%E5%8F%8Ahaving%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[group by 与 having 分组:将表格中的数据按照某一列进行分组,通常会搭配聚合函数使用,常见的聚合函数有如下几种 sum avg count min max eg 存在一个表格,结构如下 http://www.sqlcourse2.com/items_ordered.html 将订单按照customerid进行分组,并且算出每一个客户对应的订单总价 select i.customerid, sum(price) from items_ordered i group by i.customerid having sum(price) &gt; 100; tips: 假设存在另外一个表:存放customerid以及相应的客户信息.当你想要联合查询时,一般是先join之后再进行group by的操作 having是在分组之后上面进行的操作,而where的操作是在原来的每一条记录上面进行操作. select i.customerid, avg(price) from items_ordered i where i.price &gt; 10 and i.price &lt; 100 group by i.customerid having sum(price) &gt; 100; 这个查询语句的意思是:在表中先找出price在10和100之间的项,将其按照customerid进行分组,在每个分组中找出总价值大于100的分组,打印出其customerid以及平均价值.]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的synchronized和volatile]]></title>
    <url>%2F2016%2F10%2F26%2FJava%E4%B8%AD%E7%9A%84synchronized%E5%92%8Cvolatile_todo%2F</url>
    <content type="text"><![CDATA[volatile关键字 程序在运行时,为了提高性能可能会将主存中的变量拷贝到CPU缓存当中, 如果是非volatile变量,那么就可能会出现这样的问题: 线程1读取变量并且进行修改,在还没有将其写会主存的时候,线程2读取同一个变量此时就出现了问题.因为非volatile变量无法保证什么时候从主存中读取数据,也无法保证什么时候写回主存. 图示 volatile变量则可以确保了变量的修改会及时写回主存、变量直接从主存中读取 synchronized关键字 引用 http://tutorials.jenkov.com/java-concurrency/volatile.html]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的单例模式]]></title>
    <url>%2F2016%2F10%2F26%2FJava%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Java中的单例模式 多线程中可能会导致对象的多次初始化.懒汉式的实现 之所以成为懒汉,个人认为应该是类的初始化只在需要的时候进行,所以很”懒”. 线程不安全 /*懒汉 非线程安全*/ public class SingleTon_01 { private static SingleTon_01 singleTon_01 = null; private SingleTon_01() { } public static SingleTon_01 getSingleTon_01() { if (singleTon_01 == null) { singleTon_01 = new SingleTon_01(); } return singleTon_01; } public void print() { System.out.println(&quot;singleton_01&quot;); } } 线程安全/*懒汉 线程安全*/ public class SingleTon_02 { private static SingleTon_02 singleTon_02 = null; private SingleTon_02() {} private static synchronized SingleTon_02 getSingleTon_02() { if (singleTon_02 == null) { singleTon_02 = new SingleTon_02(); } return singleTon_02; } } 饿汉实现 在类加载时就进行初始化,可能会产生垃圾对象,但是不会有多线程的问题出现. /*饿汉式*/ public class SingleTon_03 { private static SingleTon_03 singleTon_03 = new SingleTon_03(); private SingleTon_03() { } public static SingleTon_03 getSingleTon_03() { return singleTon_03; } } 双重校验锁模式 要注意变量需要添加volatile关键字. 假设有两个进程分别调用了getInstance方法,进程A首先将变量复制到CPU0缓存当中,进行初始化操作,如果没有volatile关键字,那么进程B在调用此方法时复制到CPU1缓存中的可能是未被更新的null,此时问题就出现了. /*双重校验锁模式*/ public class SingleTon_04 { private static volatile SingleTon_04 singleTon_04 = null; private SingleTon_04() { } public static SingleTon_04 getSingleTon_04() { if (singleTon_04 == null) { synchronized (SingleTon_04.class) { singleTon_04 = new SingleTon_04(); } } return singleTon_04; } } 静态内部类实现 通过classloader机制确保初始化时只有一个线程 /*静态内部类*/ public class SingleTon_05 { private static class InstanceHolder{ private static SingleTon_05 singleTon_05 = new SingleTon_05(); } private SingleTon_05() { } public SingleTon_05 getSingleTon_05() { return InstanceHolder.singleTon_05; } } enum实现public enum SingleTon_06 { INSTANCE; public void print() { System.out.println(&quot;singleTon_06&quot;); } }]]></content>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android动画学习]]></title>
    <url>%2F2016%2F10%2F19%2Fandroid%E5%8A%A8%E7%94%BB%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[根据google官方的动画学习 https://developer.android.com/training/animation/index.htmlCrossfading Two Views 两个view的切换：淡入淡出效果的实现 应用场景：进度条加载完成之后内容的显示 页面代码 实现效果：在activity打开之后progressBar的alpha值逐渐下降到0直至可见性为GONE，而文本的内容的alpha值逐渐上升到1。 动画代码 private void crossfade() { // Set the content view to 0% opacity but visible, so that it is visible // (but fully transparent) during the animation. mContentView.setAlpha(0f); mContentView.setVisibility(View.VISIBLE); // Animate the content view to 100% opacity, and clear any animation // listener set on the view. mContentView.animate() .alpha(1f) .setDuration(mShortAnimationDuration) .setListener(null); // Animate the loading view to 0% opacity. After the animation ends, // set its visibility to GONE as an optimization step (it won&apos;t // participate in layout passes, etc.) mLoadingView.animate() .alpha(0f) .setDuration(mShortAnimationDuration) .setListener(new AnimatorListenerAdapter() { @Override public void onAnimationEnd(Animator animation) { mLoadingView.setVisibility(View.GONE); } }); } some tips mShortAnimationDuration = getResources().getInteger( android.R.integer.config_shortAnimTime); //200ms view.animate() 返回值为ViewPropertyAnimator,可以对其进行view上的某一个property的动画操作（例如alpha） 可以设置动画开始/结束等的监听事件，ViewPager切换效果 重点在于Viewpager的函数 mPager.setPageTransformer(true, new DepthPageTransformer()); 其中函数的第二个参数为PageTransformer接口 public interface PageTransformer { /** * Apply a property transformation to the given page. * * @param page Apply the transformation to this page * @param position Position of page relative to the current front-and-center * position of the pager. 0 is front and center. 1 is one full * page position to the right, and -1 is one page position to the left. */ public void transformPage(View page, float position); } position: 0: 前台居中 1: 前台右侧 -1:前台左侧 ZoomOutPageTransformerpublic class ZoomOutPageTransformer implements ViewPager.PageTransformer { private static final float MIN_SCALE = 0.85f; private static final float MIN_ALPHA = 0.5f; @Override public void transformPage(View view, float position) { int pageWidth = view.getWidth(); int pageHeight = view.getHeight(); if (position &lt; -1) { // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); } else if (position &lt;= 1) { // [-1,1] // Modify the default slide transition to shrink the page as well float scaleFactor = Math.max(MIN_SCALE, 1 - Math.abs(position)); float vertMargin = pageHeight * (1 - scaleFactor) / 2; float horzMargin = pageWidth * (1 - scaleFactor) / 2; if (position &lt; 0) { view.setTranslationX(horzMargin - vertMargin / 2); } else { view.setTranslationX(-horzMargin + vertMargin / 2); } // Scale the page down (between MIN_SCALE and 1) view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); // Fade the page relative to its size. view.setAlpha(MIN_ALPHA + (scaleFactor - MIN_SCALE) / (1 - MIN_SCALE) * (1 - MIN_ALPHA)); } else { // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); } } } 根据position对view进行位置的偏移(translation)以及大小的缩放(scale)以及透明度(alpha)的调整. DepthPageTransformerpublic class DepthPageTransformer implements ViewPager.PageTransformer { private static final float MIN_SCALE = 0.75f; public void transformPage(View view, float position) { int pageWidth = view.getWidth(); if (position &lt; -1) { // [-Infinity,-1) // This page is way off-screen to the left. view.setAlpha(0); } else if (position &lt;= 0) { // [-1,0] // Use the default slide transition when moving to the left page view.setAlpha(1); view.setTranslationX(0); view.setScaleX(1); view.setScaleY(1); } else if (position &lt;= 1) { // (0,1] // Fade the page out. view.setAlpha(1 - position); // Counteract the default slide transition view.setTranslationX(pageWidth * -position); // Scale the page down (between MIN_SCALE and 1) float scaleFactor = MIN_SCALE + (1 - MIN_SCALE) * (1 - Math.abs(position)); view.setScaleX(scaleFactor); view.setScaleY(scaleFactor); } else { // (1,+Infinity] // This page is way off-screen to the right. view.setAlpha(0); } } } Displaying Card Flip Animations 简单来讲,这个应该指的是一些页面切换时候的动画 getFragmentManager() .beginTransaction() // Replace the default fragment animations with animator resources // representing rotations when switching to the back of the card, as // well as animator resources representing rotations when flipping // back to the front (e.g. when the system Back button is pressed). .setCustomAnimations( R.animator.card_flip_right_in, R.animator.card_flip_right_out, R.animator.card_flip_left_in, R.animator.card_flip_left_out) // Replace any fragments currently in the container view with a // fragment representing the next page (indicated by the // just-incremented currentPage variable). .replace(R.id.container, new CardBackFragment()) // Add this transaction to the back stack, allowing users to press // Back to get to the front of the card. .addToBackStack(null) // Commit the transaction. .commit(); 核心方法为:setCustomeAnimations 具体的代码可以参见https://developer.android.com/training/animation/cardflip.htmlZooming a ViewAnimating Layout Changes layout布局变化的时候的动画是自带的,配置如下: &lt;LinearLayout android:id=&quot;@+id/container&quot; android:animateLayoutChanges=&quot;true&quot; ... /&gt; 接下来只需要直接在代码中addView中就可以了. 下一篇要写的是属性动画的另外一些应用]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java正则表达式SomeTips]]></title>
    <url>%2F2016%2F10%2F16%2FJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[默认的写法均为贪婪的 加?之后修改为最短匹配 Pattern pattern = Pattern.compile(&quot;\\d{1,3}&quot;); String s = &quot;123-456-789&quot;; Matcher matcher = pattern.matcher(s); Matcher类 matches() 方法返回boolean，判断整个字符串是否符合pattern。 find() 方法返回boolean， 判断字符串中是否存在子串符合pattern,通过group()方法获得匹配的子串。 while (matcher.find()) { System.out.println(matcher.group()); }]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android动画简介]]></title>
    <url>%2F2016%2F10%2F10%2Fandroid%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[ViewAnimation视图动画基类是Animation，包含的子类有 AlphaAnimation 透明度动画 TranslateAnimation 平移动画 ScaleAnimation 缩放动画 RotateAnimation 旋转动画 AnimationSet 动画集合 定义方法 java代码 xml文件定义 xml文件 res-&gt;anim-&gt;view_alpha.xml java文件 Animation animation = AnimationUtils.loadAnimation(getApplicationContext(), R.anim.view_alpha); PropertyAnimation属性动画 google官方api 与视图动画的区别 视图动画比较局限,仅能够修改view对象,局限于view对象的一些特定属性:例如scale,alpha等. 视图动画仅仅是修改了view绘制的地方而非view本身的属性.(在你移动一个按钮到新的位置时,点击新的位置的按钮并不能够触发事件监听)ValueAnimator 使用: ValueAnimator animation = ValueAnimator.ofFloat(0f, 1f); animation.setDuration(1000); animation.start(); 一般不直接使用这个,因为其只能够修改值而不能够将其值作用于目标上,这个类一般是作为下面的ObjectAnimator的内部实现. 常用的几个方法为ofFloat ofInt ofArgb ofObject. ofObject时需要传递实现了TypeEvaluator接口的类以提供计算方法.TypeEvaluator文档ObjectAnimator 使用: ObjectAnimator anim = ObjectAnimator.ofFloat(foo, &quot;alpha&quot;, 0f, 1f); anim.setDuration(1000); anim.start(); 常用的方法与ValueAnimator相同 第一个参数是target,即需要进行操作的类 第二个参数是property,target类中存在的变量,需要有setter方法,当setter方法不存在时: 添加方法 使用包装类 使用valueAnimator类 注意,有时候可能需要在动画的update监听器当中调用view的invalidate()方法来进行页面的重画. tips 通过调用addListener添加动画监听器 由于AnimatorListener需要实现的方法较多,所以google提供了另外一个实现了AnimatorListener接口的抽象类AnimatorListenerAdapter,你只需要实现这个类里面的某个方法即可(当你仅仅需要监听其中的某个方法的时候),其他方法默认为空实现.xml定义动画 定义在res下的animator文件夹中 &lt;set android:ordering=&quot;sequentially&quot;&gt; &lt;set&gt; &lt;objectAnimator android:propertyName=&quot;x&quot; android:duration=&quot;500&quot; android:valueTo=&quot;400&quot; android:valueType=&quot;intType&quot;/&gt; &lt;objectAnimator android:propertyName=&quot;y&quot; android:duration=&quot;500&quot; android:valueTo=&quot;300&quot; android:valueType=&quot;intType&quot;/&gt; &lt;/set&gt; &lt;objectAnimator android:propertyName=&quot;alpha&quot; android:duration=&quot;500&quot; android:valueTo=&quot;1f&quot;/&gt; &lt;/set&gt; java代码 AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.anim.property_animator); set.setTarget(myObject); set.start(); 还未涉及到的… animatorset 动画集合的使用 xml定义动画的具体使用:当valueType时的处理方法]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见布局]]></title>
    <url>%2F2016%2F10%2F10%2Ftodo%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[LinearLayout 线性布局 分为水平（horizontal）布局以及垂直布局（vertical） 一般使用layout-weight来分隔页面，使用layout-weight时，推荐将height（垂直布局时）或者weight（水平布局时）设置为0. RelativeLayout&lt;!–more__&gt; 相对布局 可以相对其他控件，也可以相对父控件TableLayout 表格布局 每一行TableRowFrameLayout 帧布局AbsoluteLayout 绝对布局 基本不用]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TravelMap]]></title>
    <url>%2F2016%2F10%2F08%2FtravelMap%2F</url>
    <content type="text"><![CDATA[Activity通知更新Fragment：通过Fragment的onAttach()函数以及使用handler：在Fragment类中定义handler成员并且重载handleMessage()函数，在handlerMessage函数中进行根据Message的信息来进行相应的操作来更新Fragment，那么怎么将Activity怎么使用这个handler呢？因为他们并不是在同一个类中，所以我在Activity中也有一个handler，在OnAttach的时候将其赋值为handler，一开始有考虑将这个handler设置为fragment类的静态成员变量，但是考虑到这样会带来其他的问题（静态成员变量就与具体的对象无关而与类相关了）。 Fragment通知更新Activity数据由Activity来实现一个接口，在Fragment的onAttach函数中可以将这个接口传递给Fragment，再通过这个接口来调用我们想要更新的Activity的数据。 Bitmap oom其实这个问题我们一开始也没有想到。因为我负责的那一块在显示一些图片的时候一直会有问题，经常是整个黑色的什么都没有，但是队友做的那部分却一切正常。所以也是被这个问题坑了很久。知道问题后解决其实就不麻烦了，通过使用BitmapFactory的一些选项设置可以达到获得缩略图片的效果，自然问题也就迎刃而解了。 同一个界面，判断是否是不同的使用类型因为在同一个界面上，我们可能是想要新建一个项，也可能是想要编辑一个项，那怎么判断比较好呢？最后我们的解决方法是使用一个布尔值得成员变量来帮助判断，而在其他界面跳转过来时根据携带的信息来确定这个成员变量的布尔值。 拍照很坑的地方当时是使用一个startActivityForResult的方法来启动相机并且传入了相应的Uri，因为需要保存文件，同时也需要将拍到的照片在界面上面显示出来，所以，坑的地方就出现了，在返回的data里面获得的图片是空的，本来还想着说能够很方便地把结果给显示出来，没想到还是得根据uri自己去把图片加载出来。 ListView的优化架构每个Activity均实现同一个接口，实现接口函数。新建一个继承自Handler的类，重载handlerMessage函数，在函数中调用上述提到的接口函数，。然后我们再在Thread中调用使用handler就可以了。 使用ViewPager时滑动冲突新建一个类继承自ViewPager，直接将其滑动事件禁用掉。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android序列化]]></title>
    <url>%2F2016%2F10%2F08%2Fandroid%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[实现Serializable接口Serializable接口是来自Java的序列化接口 使用方法class BagOfPrimitives implements Serializable{ public int value1 = 1; public String value2 = &quot;abc&quot;; public transient int value3 = 3; } 在Intent中传递对象时 取出对象实现Parcelable接口Android自带的接口，性能更高，但通用性不强使用方法如下 Parcel为参数的构造函数中，给变量赋值 writeToParcel(Parcel dest, int flags)将变量的值写入dest public class Person implements Parcelable { private int data; private Book book; protected Person(Parcel in) { data = in.readInt(); book = in.readParcelable(Book.class.getClassLoader()); } public static final Creator&lt;Person&gt; CREATOR = new Creator&lt;Person&gt;() { @Override public Person createFromParcel(Parcel in) { return new Person(in); } @Override public Person[] newArray(int size) { return new Person[size]; } }; @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeInt(data); dest.writeParcelable(book, flags); } } 重点 序列化的成员变量也需要实现Parcel接口，同时读取以及写入方式如下 读取 book = in.readParcelable(Book.class.getClassLoader()); 写入 dest.writeParcelable(book, flags); 传递对象时 接收对象时]]></content>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA中的引用]]></title>
    <url>%2F2016%2F10%2F07%2FJAVA%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[强引用 最普遍的情况 宁愿抛出OOM也不会将其回收 可以通过将引用设置为null来弱化引用，便于gc回收对象软引用 SoftReference 内存空间足够时不会回收，如果内存空间不足了，就会将其回收。 String str=new String(&quot;abc&quot;); // 强引用 SoftReference&lt;String&gt; softRef=new SoftReference&lt;String&gt;(str); 弱引用WeakReference 比软引用更加弱，当垃圾收集器回收时就会被回收。虚引用]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于RecyclerView以及ListView中的图像加载问题]]></title>
    <url>%2F2016%2F10%2F07%2F%E5%85%B3%E4%BA%8ERecyclerView%E4%BB%A5%E5%8F%8AListView%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[ListView 中出现错位，重复的图片 原因：为了性能的提升，我们一般会采取重复使用item的方式，应用仅仅需要inflate n（屏幕所能显示的item总数）个view而非数据的size个view，这样可以极大地提高效率，如下 public View getView(int position, View convertView, ViewGroup parent) { ViewHolder holder = null; if (convertView != null) { holder = (ViewHolder)convertView.getTag(); } else { convertView = mInflater.inflate(R.layout.item_list_view, parent, false); holder = new ViewHolder(); holder.imageView = (ImageView)convertView.findViewById(R.id.image_view_list_view); holder.textView = (TextView)convertView.findViewById(R.id.text_view_list_view); convertView.setTag(holder); } ...... } 但是，随之而来的问题是：图片异步加载时可能会导致的错乱问题。当第一个图片在后台线程进行加载时（可能是网络下载），在还没有下载完成的时候，我们对listview进行滚动，这个时候的item的view是复用的，所以当图片加载完成后，会将图片设置到后面的某个item里。 解决方法：通过给imageView设置tag（将tag设置为uri），在设置图片时，进行比较，不等的设置为默认值。 ImageView imageView = holder.imageView; String tag = (String) imageView.getTag(); String url = items.get(position).getUrl(); if (!url.equals(tag)) { imageView.setImageDrawable(mDefaultBitmapDrawable); } imageView.setTag(url); imageLoader.bindBitmap(url, imageView, 100, 100); RecyclerView类似的 public void onBindViewHolder(ViewHolder holder, int position) { String tag = (String) holder.imageView.getTag(); if (!items.get(position).getUrl().equals(tag)) { } holder.imageView.setTag(items.get(position).getUrl()); imageLoader.bindBitmap(items.get(position).getUrl(), holder.imageView, 500, 500); }]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android常用工具包]]></title>
    <url>%2F2016%2F10%2F07%2Fandroid%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Github地址https://github.com/wz-wilbertwu/android-util 包含AppUtilBitmapLoadBitmapLruCacheDiskLruCacheDownloadUtilFileUtiImageLoaderImageResizerLogUtiMd5Util]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntentService简介及简单使用]]></title>
    <url>%2F2016%2F10%2F07%2FIntentService%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用 创建类继承IntentService public class CustomIntentService extends IntentService { /** * Creates an IntentService. Invoked by your subclass&apos;s constructor. * */ public CustomIntentService() { super(&quot;custom intent service&quot;); } @Override protected void onHandleIntent(Intent intent) { LogUti.d(&quot;on handle intent&quot;); LogUti.d(intent.getStringExtra(&quot;key&quot;)); SystemClock.sleep(6000); LogUti.d(&quot;after 6000ms&quot;); } } 在manifest中定义service &lt;service android:name=&quot;custome_service.CustomIntentService&quot;&gt;&lt;/service&gt; 在activity中启动IntentService findViewById(R.id.btn_start_intent_service).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(IntentServiceActivity.this, CustomIntentService.class); intent.putExtra(&quot;key&quot;, &quot;value&quot;); startService(intent); } 启动服务之后调用的是onHandleIntent方法注意onHandleIntent方法不运行在UI线程所以没有办法进行界面的操作：例如toast显示结果如下图 IntentService与Activity进行交互通过本地广播的方式进行 在IntentService中 Intent localIntent = new Intent(CustomConstans.BROADCAST_ACTION); localIntent.putExtra(CustomConstans.BROADCAST_KEY, &quot;from intent service&quot;); LocalBroadcastManager.getInstance(this).sendBroadcast(localIntent); 在Activity中 新建类继承broadcastreceiver private class ResponseReceive extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context, intent.getStringExtra(CustomConstans.BROADCAST_KEY) , Toast.LENGTH_SHORT).show(); } } 注册广播 IntentFilter intentFilter = new IntentFilter(CustomConstans.BROADCAST_ACTION); ResponseReceive responseReceive = new ResponseReceive(); LocalBroadcastManager.getInstance(this).registerReceiver(responseReceive, intentFilter); tips onHandleIntent方法运行在后台线程，无法进行界面操作。 通过本地广播的方式来跟activity进行交互。 Work requests run sequentially. If an operation is running in an IntentService, and you send it another request, the request waits until the first operation is finished.顺序执行]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试一些知识点]]></title>
    <url>%2F2016%2F10%2F03%2F%E9%9D%A2%E8%AF%95%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔试题目]]></title>
    <url>%2F2016%2F09%2F26%2FAndroid%E7%AC%94%E8%AF%95%E9%A2%98%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[title: Android基础笔试题tags: android 笔试activity的启动过程 onCreate()-&gt;onStart()-&gt;onResume()-&gt;运行-&gt;onPause()-&gt;onStop()-&gt;onDestroy. 注意，当启动新的activity或切换到桌面时，回调onPause和onStop，切换回来的时候，回调onRestart-&gt;onStart-&gt;onResume。 back回退时，回调onPause，onStop，onDestroy。 如果被系统回收的话，则与初次启动回调函数一样，但是在onCreate中会有个状态保存的变量供恢复数据 旧Activity的onPause先调用，然后新Activity才启动。 意外情况activity被销毁的时候，会调用onSaveInstanceState保存状态，再将Bundle对象传递给onRestoreInstanceState和onCreate方法。 资源内存不足导致activity被杀死 优先级：前台&gt;可见但非前台（弹出对话框的activity）&gt;后台（已经被暂停的） activity的启动模式有 标准模式 singleTop 栈顶复用模式，如果在栈顶，则不重新创建，同时调用onNewIntent方法 singleTask 栈内复用,在一个新的task中产生这个实例，以后每次调用都会使用这个。 singleInstance 单实例模式，与singleTask模式基本一样，区别在于在这个模式下的activity实例所处的task中只有这个实例而不会有其他的实例。 数据存储方式 sharedpreferrence：xml格式，简单的键值对，有缓存，注意多线程访问时候可能出现的问题 普通文件存储 SQLite数据库：轻量级的数据库，使用openHelper，cursor，SQLiteDataBase。 ContentProvider。cursor，provider。 网络。httpURLconnection。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AIDL]]></title>
    <url>%2F2016%2F09%2F26%2FAIDL%2F</url>
    <content type="text"><![CDATA[Aidl:android interface definition languageaidl是安卓中一种跨进程通信的方式。 服务端 创建一个service来监听客户端的连接请求 创建aidl文件，声明将要供客户端使用的接口以及方法 在service中实现接口方法。客户端 绑定服务端的service 将服务端返回的Binder对象转化成AIDL接口的类型 那么我们就能够在客户端中实现调用AIDL的方法了。（跨进程方法调用）]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异步消息处理]]></title>
    <url>%2F2016%2F09%2F26%2FHandler_async_task%2F</url>
    <content type="text"><![CDATA[HandlerHandler的使用 继承Handler类，Override它的handleMessage方法（处理消息） Handler handler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); textView.setText(&quot;after handling&quot; + msg.getData().getString(&quot;key&quot;)); } }; tips:Message可能需要用到的两个成员分别是 msg.what msg.setData(),msg.getData() 在新开的线程中使用handler的sendMessage方法发送消息，以达到修改UI元素的效果。 new Thread(new Runnable() { @Override public void run() { Message msg = new Message(); Bundle bundle = new Bundle(); bundle.putString(&quot;key&quot;, textView.getText().toString()); msg.setData(bundle); handler.sendMessage(msg); } }).start(); 一些思考 MessageQueue：消息队列 Looper：循环，一直从消息队列中获得消息，如果没有消息则一直循环。成员变量有MessageQueue。ThreadLocal变量，每个线程唯一且相同。 Handler：成员变量有Looper，亦即也拥有MessageQueue，发送消息时向消息队列插入消息，有Looper负责发现消息并且根据Message的target（亦即handler）来负责处理消息。 * 所以，当我们在子线程中用handler发送消息时，插入的MessageQueue是主线程的MessageQueue，此时由handler的操作便变成了主线程的操作而非在子线程中操作界面。 AsyncTask 继承AsyncTask类 //参数，运行时返回值类型，结果类型 class DownloadTask extends AsyncTask&lt;String, Integer, Boolean&gt; { int count = 0; //任务启动前执行的函数 @Override protected void onPreExecute() { progressDialog.show(); } //后台执行的函数，可以进行耗时操作 @Override protected Boolean doInBackground(String... params) { while (true) { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } count++; if (count &gt;= 10) { break; } //这个方法会调用更新进度显示的函数。 publishProgress(count); } return true; } //更新进度显示 @Override protected void onProgressUpdate(Integer... values) { progressDialog.setMessage(&quot;downloaded &quot; + values[0]*10 + &quot;%&quot;); } //后台执行完成之后调用。 @Override protected void onPostExecute(Boolean aBoolean) { progressDialog.dismiss(); if(aBoolean) { Toast.makeText(MessageHandleActivity.this, &quot;succeed&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(MessageHandleActivity.this, &quot;failed&quot;, Toast.LENGTH_SHORT).show(); } } }]]></content>
      <tags>
        <tag>android</tag>
        <tag>第一行代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service]]></title>
    <url>%2F2016%2F09%2F26%2FService%2F</url>
    <content type="text"><![CDATA[Service基本用法和Activity进行通信 继承Binder对象 public class DownloadBinder extends Binder{ int count = 0; Handler handler; public void setHandler(Handler handler) { this.handler = handler; } public void startDownload() { } } 继承Service，Override onBind函数,新增成员：DownloadBinder。 public class MyService extends Service { DownloadBinder downloadBinder = new DownloadBinder(); @Nullable @Override public IBinder onBind(Intent intent) { return downloadBinder; } } Activity中，连接时获得DownloadBinder实例，这样就可以通过Binder来与Service进行通信。 ServiceConnection connection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { binder = (MyService.DownloadBinder) service; binder.setHandler(handler); binder.startDownload(); } @Override public void onServiceDisconnected(ComponentName name) { }}; 绑定service Intent intent = new Intent(ServiceLearnActivity.this, MyService.class); bindService(intent, connection, BIND_AUTO_CREATE); 生命周期 startService方法调用时，启动相应的服务，如果服务之前没有创建，那么会先回调onCreate方法，接下来回调onStartCommand方法。 每个服务只会存在一个实例。 bindService方法：回调onBind方法：如果服务之前还没有创建，那么会先回调onCreate方法。]]></content>
      <tags>
        <tag>android</tag>
        <tag>第一行代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity]]></title>
    <url>%2F2016%2F09%2F26%2FActivity%2F</url>
    <content type="text"><![CDATA[Activityres目录 drawable 存放图片 R.drawable.XXX @drawable/XXX values 存放字符串 代码中：R.string.XXX xml中：@string/XXX layout 存放布局文件 menu 存放菜单文件 项目中任何添加的资源都会在R文件中生成一个相应的资源id。 添加菜单 res下新建menu文件夹，添加菜单文件（res的menu文件夹中） 重写onCreateOptionsMenu方法 @Override public boolean onCreateOptionsMenu(Menu menu) { this.getMenuInflater().inflate(R.menu.main, menu); return true; } 响应点击按钮事件 @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { case R.id.set_item: Toast.makeText(this, &quot;设置&quot;, Toast.LENGTH_SHORT).show(); } return true; } Intent隐式intent待启动的activity 在需要响应内容的Activity中添加action以及category字段，只有当这两个字段完全匹配上intent的相应的值时，才可以启动activity。 intent构造函数：action字符串传入，默认情况下会插入 “android.intent.category.DEFAULT” intent-filter可以指定data标签，更精确的指定当前activity能够响应的数据 &lt;data android:scheme=&quot;http&quot; android:mimeType=&quot;XXX&quot;&gt;&lt;/data&gt; 除此之外，还能够匹配host，port，path等，只有当这些值完全匹配，才会被启动。 隐式启动activity时 intent 可以指定多个category Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;)); Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(&quot;tel:10086&quot;)); intent setDateAndType（，）两个参数分别是uri以及文件类型.http://blog.csdn.net/chaoyu168/article/details/50778016activity之间传递数据 传递给下一个界面 在intent当中putExtra就可以了,在下一个界面当中getIntent获得intent就可以读取里面的内容了。 可以直接使用key-value的方式插入intent中，也可以通过bundle类来进行插入，bundle类类似一个map，能够简化操作。 实现了序列化接口的类对象也可以通过intent传递。 对接时怎么样传递数据比较好呢？ 在被启动的页面中新增一个静态方法actionStart(),参数需要有context，然后参数列表是需要传递的数据，这样在前一个页面中直接调用这个方法就可以启动新的页面了。 startActivityForResult 启动时传入requestCode 重写onActivityResult方法，根据参数中的requestCode判断是哪个的回调。 必要时还需要重写被启动页面的返回键回调函数onBackPress() 生命周期 Activity被回收了 onSaveInstanceState(Bundle) onCreate(Bundle) 启动模式 standard模式 singleTop模式 栈顶如果是要启动的activity，则不新建，仅此而已。 singleTask模式 检查返回栈中是否存在类的实例，如果存在将其上的所有activity出栈。 singleInstance模式 存放在一个新的返回栈里面。]]></content>
      <tags>
        <tag>android</tag>
        <tag>第一行代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View]]></title>
    <url>%2F2016%2F09%2F26%2FView%2F</url>
    <content type="text"><![CDATA[追踪手指在滑动过程中的速度@Override public boolean onTouchEvent(MotionEvent event) { VelocityTracker velocityTracker = VelocityTracker.obtain(); velocityTracker.addMovement(event); velocityTracker.computeCurrentVelocity(1000); int x = (int)velocityTracker.getXVelocity(); int y = (int)velocityTracker.getYVelocity(); Log.d(W, &quot;x:&quot; + x + &quot;,y:&quot; + y); return super.onTouchEvent(event); } 检测手势行为implements GestureDetector.OnGestureListener @Override public boolean onTouchEvent(MotionEvent event) { boolean consume = gestureDetector.onTouchEvent(event); return consume; } 滑动scrollTo&amp;&amp;scrollerBy使用动画改变布局参数public void onClick(View v) { ViewGroup.MarginLayoutParams marginLayoutParams = (ViewGroup.MarginLayoutParams)button.getLayoutParams(); Log.d(W, &quot;layout&quot;); marginLayoutParams.width += 100; marginLayoutParams.leftMargin += 100; button.requestLayout(); }]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UI]]></title>
    <url>%2F2016%2F09%2F26%2FUI%2F</url>
    <content type="text"><![CDATA[TextView android:gravity top bottom left right等等，指定对齐方向 match_parent fill_parent wrap_content EditTextmaxLine ImageViewimageView.setImageResource(R.mipmap.abc); visible invisible gone属性 visible 可见 invisible 不可见但是还存在 gone 不可见不存在 View setVisibilty() View.gone … AlertDialog AlertDialog.Builder builder = new AlertDialog.Builder(UIActivity.this); builder.setTitle(&quot;AlertDialogTitle&quot;); builder.setCancelable(false); builder.setMessage(&quot;some message&quot;); builder.setPositiveButton(&quot;Yes&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { } }); builder.setNegativeButton(&quot;No&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { } }); builder.show(); LinearLayout 指定方向，要注意如果是水平方向的话，则内部控件的宽度不能够是match_parent的不然会充满整个布局，同理竖直方向也是类似的。 android:layout_gravity属性：正如TextView中gravity表示文本内容占据整个宽度的位置，这个属性指的是控件在LinearLayout中的相对位置，而且，当外层layout是竖直布局时在其上的关于竖直的设置是不会生效的。注意，这个属性亦是属于子布局里面的而不是属于LinearLayout（要指定的是每一个不同的子布局）。 android:layout_weight属性：系统会先把 LinearLayout 下所有控件指定的 layout_weight 值相加， 得到一个总值，然后每个控件所占大小的比例就是用该控件的 layout_weight 值除以刚才算出的总值。 布局中的如果只有部分控件有weight属性，则有weight属性的控件共享剩下的宽度或者高度（按照比例分配）。 RelativeLayout 相对布局dp和sp在编写 Android 程序的时候，尽量将控件或布局的大小指定成 match_parent或 wrap_content，如果必须要指定一个固定值，则使用 dp 来作为单位，指定文字大小的时候使用 sp 作为单位。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广播接收器]]></title>
    <url>%2F2016%2F09%2F26%2Fbroadcast%2F</url>
    <content type="text"><![CDATA[广播机制 标准广播 完全异步执行 所有广播接收器几乎同时收到 有序广播 同步执行 优先级高的先收到，可以截断。 系统广播 broadcast receiver 不允许开启线程 onReceive 中的context的来源，是谁在调用这个函数 // todo 静态注册 manifest中注册 &lt;intent-filter&gt; &lt;action android:name=&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;&gt;&lt;/action&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 动态注册 代码中注册 继承类 class NetworkChangeReceiver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { ConnectivityManager manager = (ConnectivityManager) getSystemService(CONNECTIVITY_SERVICE); NetworkInfo info = manager.getActiveNetworkInfo(); /* Intent intent1 = new Intent(context, SettingActivity.class); startActivity(intent1); */ if (info != null &amp;&amp; info.isAvailable()) { Toast.makeText(context, &quot;network is available&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(context, &quot;network is unavailable&quot;, Toast.LENGTH_SHORT).show(); } } } 注册广播，在onCreate中添加 IntentFilter intentFilter = new IntentFilter(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;); registerReceiver(receiver, intentFilter); 注意要在onDestroy函数中取消注册。 自定义广播接收器 与隐式intent类似，可以在intent-filter中添加自定义的action，发送广播时调用sendBroadCast(Intent intent)。此时发送的是标准广播，同时也可以发送一些数据，在intent当中。 sendOrderedBroadCast() 发送有序广播 本地广播功能LocalBroadCastManager getInstance()方法 初始化localBroadCastManager localBroadCastManager = LocalBroadCastManager.getInstance(this); 注册 localBroadCastManager.register….. 发送 localBroadCastManager.send…… 销毁 localBroadCastManager .unregister….. 本地广播无法使用静态注册。 tips 在广播接收器里启动activity时，需要给Intent加入FLAG_ACTIVITY_NEW_TASK标志。]]></content>
      <tags>
        <tag>android</tag>
        <tag>第一行代码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecycleView]]></title>
    <url>%2F2016%2F09%2F26%2FRecycleView%2F</url>
    <content type="text"><![CDATA[创建RecycleView.Adapter的继承类 其中存在内部静态类：继承 RecyclerView.ViewHolder. 内部静态类： public static class ViewHolder extends RecyclerView.ViewHolder{ public Button button; public ViewHolder(View t) { super(t); button = (Button) t.findViewById(R.id.item_text_view); }} 重载函数 onCreateViewHolder @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { final View view = LayoutInflater.from(parent.getContext()) .inflate(R.layout.my_text_view, parent, false); ViewHolder viewHolder = new ViewHolder(view); return viewHolder; } 重载onBindViewHolder，设置每一个item的内容 @Override public void onBindViewHolder(ViewHolder holder, int position) { //每个item的具体设置 holder.button.setText(dataSet.get(position)); } 实现按钮监听的方法 声明接口 public interface IOnItemClick { void onItemClick(View view); } 在Activity中实现接口 MenuAdapter.IOnItemClick iOnItemClick = new MenuAdapter.IOnItemClick() { @Override public void onItemClick(View view) { //此处的view为每个item的View而非里面的按钮之类的 int itemPosition = recyclerView.getChildLayoutPosition(view); } } 在初始化Adapter中，将接口的实现类传进去。 在Adapter中。 @Override public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) { final View view = LayoutInflater.from(parent.getContext()) .inflate(R.layout.my_text_view, parent, false); ViewHolder viewHolder = new ViewHolder(view); if(iOnItemClick != null) { viewHolder.button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { iOnItemClick.onItemClick(view); //此处调用的view为上面所述的view而非按钮v } }); } return viewHolder; }]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于handler以及一些回调的思考]]></title>
    <url>%2F2016%2F06%2F23%2F%E5%85%B3%E4%BA%8Ehandler%E4%BB%A5%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9B%9E%E8%B0%83%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[有线程如下： public class SetTextThread extends Thread { private IIsetText iIsetText; private Handler handler; private MyNum myNum; public SetTextThread(IIsetText iIsetText) { this.iIsetText = iIsetText; } public SetTextThread(Handler handler) { this.handler = handler; } public SetTextThread(MyNum myNum) { print(&quot;constructor:&quot; + Thread.currentThread()); this.myNum = myNum; } @Override public void run() { print(&quot;run:&quot; + Thread.currentThread()); // iIsetText.setText(); // handler.sendMessage(new Message()); myNum.i = 9999; } public void print(String s) { System.out.println(s); } } 多线程中，变量虽然相同，但是其实他们指向的是不同的内存区域，所以修改是不会影响到互相的值的。//此处有待确认正确与否，待查看thinking in java后再行确定。 handler中，首先要先了解handler的消息机制 MessageQueue：消息队列 Looper：循环，一直从消息队列中获得消息，如果没有消息则一直循环。成员变量有MessageQueue。ThreadLocal变量，每个线程唯一且相同。 Handler：成员变量有Looper，亦即也拥有MessageQueue，发送消息时向消息队列插入消息，有Looper负责发现消息并且根据Message的target（亦即handler）来负责处理消息。 所以，当我们在子线程中用handler发送消息时，虽然说此时的handler是另外线程中主线程handler的复制品，但是内容是完全一样的，亦即其Looper与消息队列依然是主线程的，所以，当发送消息时，插入的MessageQueue依旧是主线程，此时由handler的操作便变成了主线程的操作而非在子线程中操作界面。]]></content>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[helloworld]]></title>
    <url>%2F2016%2F06%2F23%2F%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[android面试题目Service Activity中 void initData() { mConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { myBinder = (MyBinder)service; myBinder.showMessage(); } @Override public void onServiceDisconnected(ComponentName name) { SomeMethod.makeToast(ServiceActivity.this, &quot;service disconnected&quot;); } }; } public void onClick(View v) { Intent intent = null; switch (v.getId()) { case R.id.startSerBtn: intent = new Intent(this, MyService.class); startService(intent); break; case R.id.endSerBtn: intent = new Intent(this, MyService.class); stopService(intent); break; case R.id.bindBtn: intent = new Intent(this, MyService.class); bindService(intent, mConnection, BIND_AUTO_CREATE); isBind = true; break; case R.id.unBinBtn: if (isBind) { unbindService(mConnection); isBind = false; } break; } } } MyBinder类 public class MyBinder extends Binder { Context mContext; public MyBinder(Context context) { mContext = context; } public void showMessage() { SomeMethod.makeToast(mContext, &quot;in myBinder&quot;); } } MyService类 public class MyService extends Service { public static final String w = &quot;wilbert&quot;; @Override public void onCreate() { super.onCreate(); SomeMethod.makeToast(this, &quot;onCreate&quot;); Log.d(w, &quot;onCreate&quot;); myBinder = new MyBinder(this); } @Override public int onStartCommand(Intent intent, int flags, int startId) { Log.d(w, &quot;onStartCommand&quot;); SomeMethod.makeToast(this, &quot;onStartCommand&quot;); return super.onStartCommand(intent, flags, startId); } @Override public void onDestroy() { SomeMethod.makeToast(this, &quot;onDestroy&quot;); Log.d(w, &quot;onDestroy&quot;); super.onDestroy(); } MyBinder myBinder; @Nullable @Override public IBinder onBind(Intent intent) { Log.d(w, &quot;onBind&quot;); return myBinder; } } 数据库 OpenHelper package com.wilbert.firstlinecode.DB; import android.content.Context; import android.database.sqlite.SQLiteDatabase; import android.database.sqlite.SQLiteOpenHelper; import android.widget.Toast; /** * Created by wilbert on 2016/4/15. */ public class DbOpenHelper extends SQLiteOpenHelper { public static final String CREATE_BOOK = &quot;create table book (&quot; + &quot;id integer primary key autoincrement, &quot; + &quot;author text, &quot; + &quot;price real, &quot; + &quot;pages integer, &quot; + &quot;name text)&quot;; public static final String CREATE_CATEGORY = &quot;create table Category (&quot; + &quot;id integer primary key autoincrement, &quot; + &quot;category_name text, &quot; + &quot;category_code integer)&quot;; private Context mContext; public DbOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) { super(context, name, factory, version); mContext = context; } @Override public void onCreate(SQLiteDatabase db) { db.execSQL(CREATE_BOOK); db.execSQL(CREATE_CATEGORY); Toast.makeText(mContext, &quot;create db successfully&quot;, Toast.LENGTH_SHORT).show(); } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } } SqlActivity public class SqlActivity extends BaseActivity { Button createDbBtn; Button insertBtn; Button updateBtn; Button deleteBtn; ListView sqlListview; DbOpenHelper dbOpenHelper; SQLiteDatabase sqLiteDatabase; List&lt;String&gt; stringList = new ArrayList&lt;String&gt;(); ArrayAdapter&lt;String&gt; arrayAdapter; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_sql); initView(); initData(); Log.v(&quot;w&quot;, &quot;onCreate&quot;); } @Override void initView() { createDbBtn = (Button)findViewById(R.id.createDbBtn); createDbBtn.setOnClickListener(this); insertBtn = (Button)findViewById(R.id.insertBtn); insertBtn.setOnClickListener(this); updateBtn = (Button)findViewById(R.id.updateBtn); updateBtn.setOnClickListener(this); deleteBtn = (Button)findViewById(R.id.deleteBtn); deleteBtn.setOnClickListener(this); sqlListview = (ListView)findViewById(R.id.dbListview); } @Override void initData() { dbOpenHelper = new DbOpenHelper(this, &quot;BookStore&quot;, null, 1); sqLiteDatabase = dbOpenHelper.getWritableDatabase(); readDataFromSql(); arrayAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1 , stringList); sqlListview.setAdapter(arrayAdapter); } private void readDataFromSql() { stringList.clear(); Cursor cursor = sqLiteDatabase.query(Book.TABLE_NAME, null, null, null, null, null, null); if (cursor.moveToFirst()) { do { stringList.add(Book.getBookFromCursor(cursor).toString()); } while (cursor.moveToNext()); } } @Override public void onClick(View v) { switch (v.getId()) { case R.id.createDbBtn: dbOpenHelper.getWritableDatabase(); break; case R.id.insertBtn: Book book = new Book(&quot;wilbert&quot;, &quot;mybook&quot;, 99, 100); long id = sqLiteDatabase.insert(Book.TABLE_NAME, null, book.makeContenValues()); if (id != -1) { Toast.makeText(this, &quot;insert successfully&quot;, Toast.LENGTH_SHORT).show(); } break; case R.id.updateBtn: Book book2 = new Book(&quot;wilbert&quot;, &quot;mybook&quot;, 50, 100); int effects = sqLiteDatabase.update(Book.TABLE_NAME, book2.makeContenValues(), &quot;name = ?&quot;, new String[]{&quot;mybook&quot;}); if (effects != 0) { Toast.makeText(this, &quot;update successfully&quot;, Toast.LENGTH_SHORT).show(); } break; case R.id.deleteBtn: // sqLiteDatabase.beginTransaction(); int i = sqLiteDatabase.delete(Book.TABLE_NAME, &quot;pages &gt; ? OR name = ?&quot;, new String[]{&quot;10&quot;, &quot;wilbert&quot;}); if (i != 0) { showToasts(i + &quot; delete successfully&quot;); } // sqLiteDatabase.endTransaction(); break; } readDataFromSql(); arrayAdapter.notifyDataSetChanged(); } private void showToasts(String s) { Toast.makeText(this, s, Toast.LENGTH_SHORT).show(); } } ContentProvider contentProvider类 package com.wilbert.firstlinecode.model; import android.content.ContentProvider; import android.content.ContentValues; import android.content.UriMatcher; import android.database.Cursor; import android.database.sqlite.SQLiteDatabase; import android.net.Uri; import android.support.annotation.Nullable; import com.wilbert.firstlinecode.DB.DbOpenHelper; import java.net.Inet4Address; /** * Created by wilbert on 2016/4/15. */ public class BookProvider extends ContentProvider { public static final int BOOK_DIR = 0; public static final int BOOK_ITEM = 1; public static final String AUTHORITY = &quot;com.example.databasetest.provider&quot;; private static UriMatcher uriMatcher; private DbOpenHelper dbOpenHelper; private SQLiteDatabase sqLiteDatabase; static { uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_DIR); uriMatcher.addURI(AUTHORITY, &quot;book/# &quot;, BOOK_ITEM); } @Override public boolean onCreate() { dbOpenHelper = new DbOpenHelper(getContext(), &quot;BookStore&quot;, null, 1); sqLiteDatabase = dbOpenHelper.getWritableDatabase(); return true; } @Nullable @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { Cursor cursor = null; switch (uriMatcher.match(uri)) { case BOOK_DIR: cursor = sqLiteDatabase.query(&quot;Book&quot;, projection, selection, selectionArgs, null, null, sortOrder); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); cursor = sqLiteDatabase.query(&quot;Book&quot;, projection, &quot;id = ?&quot;, new String[] {bookId}, null, null, sortOrder); break; } return cursor; } @Nullable @Override public String getType(Uri uri) { switch (uriMatcher.match(uri)) { case BOOK_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.databasetest.provider.book&quot;; case BOOK_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.databasetest.provider.book&quot;; } return null; } @Nullable @Override public Uri insert(Uri uri, ContentValues values) { Uri returnUri = null; switch (uriMatcher.match(uri)) { case BOOK_DIR: case BOOK_ITEM: long newBookId = sqLiteDatabase.insert(&quot;Book&quot;, null, values); returnUri = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book/&quot; + newBookId); break; } return returnUri; } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { int deletedRows = 0; switch (uriMatcher.match(uri)) { case BOOK_DIR: deletedRows = sqLiteDatabase.delete(&quot;Book&quot;, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); deletedRows = sqLiteDatabase.delete(&quot;Book&quot;, &quot;id = ?&quot;, new String[] { bookId }); break; } return deletedRows; } @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { int updatedRows = 0; switch (uriMatcher.match(uri)) { case BOOK_DIR: updatedRows = sqLiteDatabase.update(&quot;Book&quot;, values, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); updatedRows = sqLiteDatabase.update(&quot;Book&quot;, values, &quot;id = ?&quot;, new String[] {bookId}); break; } return updatedRows; } } provider activity public void onClick(View v) { // TODO: 2016/4/15 query operation cursor String newId; switch (v.getId()) { case R.id.queryBtn: Uri uri2 = Uri.parse(&quot;content://com.example.databasetest.provider/book/1&quot;); Cursor cursor = getContentResolver().query(uri2, null, null, null, null); if (cursor != null) { Book book = Book.getBookFromCursor(cursor); stringList.add(book.toString()); arrayAdapter.notifyDataSetChanged(); } break; case R.id.insertBtn: Uri uri = Uri.parse(&quot;content://com.example.databasetest.provider/book&quot;); Book book = new Book(&quot;wilbdd&quot;, &quot;nae&quot;, 100, 100); Uri newUri = getContentResolver().insert(uri, book.makeContenValues()); //newId = newUri.getPathSegments().get(1); makeToast(&quot; &quot; + &quot;insert&quot;); makeToast(newUri.toString()); break; } }]]></content>
      <tags>
        <tag>android面试题目</tag>
      </tags>
  </entry>
</search>
